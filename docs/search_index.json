[["index.html", "Privacy protected federated omic data analysis in multi-center studies with DataSHIELD Welcome", " Privacy protected federated omic data analysis in multi-center studies with DataSHIELD 2022-01-27 Welcome This is a website for a book that serves as official documentation for OmicSHIELD. On it you will find: introductory references to learn about DataSHIELD and resources, explanation on the type of analysis that can be performed using OmicSHIELD and workflows (with reproducible code) of the main functionalities of OmicSHIELD. All the funcionalities described on this book have been developed at the Bioinformatic Research Group in Epidemiology (BRGE) of ISGlobal with external help from Yannick Marcon (Obiba); and are part of OmicSHIELD. The aim of this book is to be a showcase of the capabilities of the software we developed as well as being a quick reference guide for new researchers interested in this technology. This material also serves as an online companion for the manuscript NOMBRE DEL PAPER QUE ESCRIBIREMOS. This website is free to use, and is licensed under a MIT license. "],["introduction.html", "1 Introduction 1.1 Materials to read beforehand 1.2 What are resources: A very simple explanation without any technicalities 1.3 Capabilities of OmicSHIELD", " 1 Introduction 1.1 Materials to read beforehand Along this book, there are some details regarding DataSHIELD and resources that are not explained in detail, it is expected that the reader is familiar with them. If that is not the case, there are other free online books/papers with that knowledge. DataSHIELD paper: Description of what is DataSHIELD. DataSHIELD wiki: Materials about DataSHIELD including: Beginner material Recorded DataSHIELD workshops Information on current release of DataSHIELD resource book: In this book you will find information about: DataSHIELD (Section 5) What are resources (Section 6/7) We will be interacting with DataSHIELD through a data warehouse called Opal. This is the server that will handle the authentication of our credentials, storage of data and resources and will provide an R server where the non-disclosive analysis will be conducted. Information about it can also be foun online: Opal papers 1; 2 Opal documentation 1.2 What are resources: A very simple explanation without any technicalities It is quite important to have a solid understanding of what are the resources and how we work with them, since in all the use cases we are interacting with them to load the Omic data on the R sessions. For that reason we included a very brief description of them without using technicalities. The resources can be imagined as a data structure that contains the information about where to find a data set and the access credentials to it; we as DataSHIELD users are not able to look at this information (it is privately stored on the Opal server), but we can load it into our remote R session to make use of it. Following that, the next step comes naturally. Once we have in an R session the information to access a dataset (an ExpressionSet for example) we have to actually retrieve it on the remote R session to analyze it. This step is called resolving the resource. Those two steps can be identified on the code we provide as the following: Loading the information of a resource: DSI::datashield.assign.resource(conns, &quot;resource&quot;, &quot;resource.path.in.opal.server&quot;) Resolving the resource: DSI::datashield.assign.expr(conns, &quot;resource.resolved&quot;, expr = as.symbol(&quot;as.resource.object(resource)&quot;)) This toy code would first load the resource on a variable called resource and it would retrieve the information it contains and assign it to a variable called resource.resolved. 1.3 Capabilities of OmicSHIELD The functionalities of OmicSHIELD are built on top of the resources to work with different types of data objects, more precisely we have developed capabilities to work with the following R objects: ExpressionSet RangedSummarizedExperiment VCF/GDS (Genotype data containers) These objects are analyzed using BioConductor packages as well as custom-made functions. This ensures that researchers familiar with the BioConductor universe will feel at home when using OmicSHIELD. Not only we can work using a BioConductor approach, we also developed functionalities to make use of command line tools that are traditionally used on omics analysis, those are: PLINK SNPTEST This allow the researchers to perform analysis on federated data using their own command line based pipelines. Again this ensures that people familiar with those tools will be able to perform analysis easily. "],["Omic.html", "2 Omic data analysis: types of implemented analyses", " 2 Omic data analysis: types of implemented analyses The Figure 2.1 describes the different types of omic association analyses that can be performed using DataSHIELD client functions implemented in the dsOmicsClient package. Basically, data (omic and phenotypes/covariates) can be stored in different sites (http, ssh, AWS S3, local, ) and are managed with Opal through the resourcer package and their extensions implemented in dsOmics. Figure 2.1: Non-disclosive omic data analysis with DataSHIELD and Bioconductor. The figure illustrates how the resourcer package is used to get access to omic data through the Opal servers. Then DataSHIELD is used in the client side to perform non-disclosive data analyses. Then, dsOmicsClient package allows different types of analyses: pooled and meta-analysis. Both methods are based on fitting different Generalized Linear Models (GLMs) for each feature when assesing association between omic data and the phenotype/trait/condition of interest. Of course, non-disclosive omic data analysis from a single study can also be performed. The pooled approach (Figure 2.2) is recommended when the user wants to analyze omic data from different sources and obtain results as if the data were located in a single computer. It should be noted that this can be very time consuming when analyzing multiple features since it calls a base function in DataSHIELD (ds.glm) repeatedly. It also cannot be recommended when data are not properly harmonized (e.g. gene expression normalized using different methods, GWAS data having different platforms, ). Furthermore when it is necesary to remove unwanted variability (for transcriptomic and epigenomica analysis) or control for population stratification (for GWAS analysis), this approach cannot be used since we need to develop methods to compute surrogate variables (to remove unwanted variability) or PCAs (to to address population stratification) in a non-disclosive way. The meta-analysis approach Figure 2.3 overcomes the limitations raised when performing pooled analyses. First, the computation issue is addressed by using scalable and fast methods to perform data analysis at whole-genome level at each location The transcriptomic and epigenomic data analyses make use of the widely used limma package that uses ExpressionSet or RangedSummarizedExperiment Bioc infrastructures to deal with omic and phenotypic (e.g covariates). The genomic data are analyzed using GWASTools and GENESIS that are designed to perform quality control (QC) and GWAS using GDS infrastructure. Next, we describe how both approaches are implemented: Pooled approach: Figure 2.2 illustrate how this analysis is performed. This corresponds to generalized linear models (glm) on data from single or multiple sources. It makes use of ds.glm() function which is a DataSHIELD function that uses an approach that is mathematically equivalent to placing all individual-level data froma all sources in one central warehouse and analysing those data using the conventional glm() function in R. The user can select one (or multiple) features (i.e., genes, transcripts, CpGs, SNPs, ) Figure 2.2: Non-disclosive omic data analysis with DataSHIELD and Bioconductor. The figure illustrates how to perform single pooled omic data analysis. The analyses are performed by using a generalized linear model (glm) on data from one or multiple sources. It makes use of ds.glm(), a DataSHIELD function, that uses an approach that is mathematically equivalent to placing all individual-level data from all sources in one central warehouse and analysing those data using the conventional glm() function in R. Meta-analysis: Figure 2.3 illustrate how this analysis is performed. This corresponds to performing a genome-wide analysis at each location using functions that are specifically design for that purpose and that are scalable. Then the results from each location can be meta-analyzed using methods that meta-analyze either effect sizes or p-values. Figure 2.3: Non-disclosive omic data analysis with DataSHIELD and Bioconductor. The figure illustrates how to perform anlyses at genome-wide level from one or multiple sources. It runs standard Bioconductor functions at each server independently to speed up the analyses and in the case of having multiple sources, results can be meta-analyzed uning standar R functions. "],["genome-wide-association-study-gwas-analysis.html", "3 Genome wide association study (GWAS) analysis 3.1 Single cohort 3.2 Multi cohorts 3.3 Post-omic analysis", " 3 Genome wide association study (GWAS) analysis Three different use cases will be illustrated: Single cohort GWAS. Using data from all the individuals. Multi-cohort GWAS. Using the same individuals as the single cohort separated into three synthetic cohorts. Polygenic risk score. Using data from all the individuals. For all the illustrated cases we will use data divided by chromosome (VCF files). The procedure is the same if all the variants are on a single VCF. The phenotype information used throughout this section is not contained inside the VCF files mentioned previously, it is contained using traditional CSV/Excel files. This is to replicate the typical scenario where an investigator receives the genomic and phenotype data separated and has to merge it to study a specific relationship between the gene expression / variants and a certain phenotype. The data used along this section is a synthetic data set generated by the CINECA project made freely available under the Creative Commons Licence (CC-BY) (funding: EC H2020 grant 825775). It has been pruned and the individuals have been separated into three synthetic cohorts. For the Single cohort use case, all the individuals are used. Information on individuals and SNP count of each cohort can be found on the Table 3.1. Table 3.1: Numer of SNPs and individuals by cohort Cohort 1 Cohort 2 Cohort 3 Total Number of SNPs 865,240 865,240 865,240 865,240 Number of individuals 817 1,073 614 2,504 3.1 Single cohort  RESOURCES USED ALONG THIS SECTION From https://opal-demo.obiba.org/ : STUDY TABLE PROFILE cohort1 GWAS.chr{1..21} omics cohort1 GWAS.ega_phenotypes omics The single cohort analysis is a way of performing a GWAS study guaranteeing GDPR data confidentiality. The structure followed is illustrated on the following figure. Figure 3.1: Proposed infrastructure to perform single-cohort GWAS studies. The data analyst corresponds to the RStudio session, which through DataSHIELD Interface (DSI) connects with the Opal server located at the cohort network. This Opal server contains an array of resources that correspond to the different VCF files (sliced by chromosome)1 and a resource that corresponds to the phenotypes table of the studied individuals. 3.1.1 Connection to the Opal server We have to create an Opal connection object to the cohort server. We do that using the following functions. require(&#39;DSI&#39;) require(&#39;DSOpal&#39;) require(&#39;dsBaseClient&#39;) require(&#39;dsOmicsClient&#39;) builder &lt;- DSI::newDSLoginBuilder() builder$append(server = &quot;cohort1&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) logindata &lt;- builder$build() conns &lt;- DSI::datashield.login(logins = logindata) 3.1.2 Assign the VCF resources Now that we have created a connection object to the Opal, we have started a new R session on the server, our analysis will take place in this remote session, so we have to load the data into it. In this use case we will use 21 different resources from the GWAS project hosted on the demo Opal server. This resources correspond to VCF files with information on individual chromosomes. The names of the resources are chrXX (where XX is the chromosome number). Following the Opal syntax, we will refer to them using the string GWAS.chrXX. To load the resources we will use the DSI::datashield.assign.resource() function. Note that along the use case we use the lapply function to simplify our code since we have to perform repetitive operations. lapply is a way of creating loops in R, for more information visit the documentation. lapply(1:21, function(x){ DSI::datashield.assign.resource(conns, paste0(&quot;chr&quot;, x), paste0(&quot;GWAS.chr&quot;, x)) }) Now we have assigned all the resources named GWAS.chrXX into our remote R session. We have assigned them to the variables called chrXX. To verify this step has been performed correctly, we could use the ds.class function to check for their class and that they exist on the remote session. ds.class(&quot;chr1&quot;) $cohort1 [1] &quot;GDSFileResourceClient&quot; &quot;FileResourceClient&quot; &quot;ResourceClient&quot; [4] &quot;R6&quot; To resolve the resources and retrieve the data in the remote session we will use the DSI::datashield.assign.expr() function. This function runs a line of code on the remote session,2 and in particular we want to run the function as.resource.object(), which is the DataSHIELD function in charge of resolving the resources. lapply(1:21, function(x){ DSI::datashield.assign.expr(conns = conns, symbol = paste0(&quot;gds&quot;, x, &quot;_object&quot;), expr = as.symbol(paste0(&quot;as.resource.object(chr&quot;, x, &quot;)&quot;))) }) Now we have resolved the resources named chrXX into our remote R session. The objects retrieved have been assigned into variables named gdsXX_object. We can check the process was successful as we did before. ds.class(&quot;gds1_object&quot;) $cohort1 [1] &quot;GdsGenotypeReader&quot; attr(,&quot;package&quot;) [1] &quot;GWASTools&quot; 3.1.3 Assign the phenotypes The objects we have loaded into our remote session are VCF files that contain genomic information of the individuals. To perform a GWAS this information has to be related to some phenotypes to extract relationships. Therefore, we need to load the phenotypes into the remote session. The phenotypes information is a table that contains the individuals as rows and phenotypes as columns. In this use case, we will use a resource (as with the VCF files) to load the phenotypes table into the remote session. The procedure is practically the same as before with some minor tweaks. To begin, we have the phenotypes information in a single table (hence, a single resource). Then, instead of using the function as.resource.object, we will use as.resource.data.frame, this is because before we were loading a special object (VCF file) and now we are loading a plain table, so the internal treatment on the remote session has to be different. DSI::datashield.assign.resource(conns, &quot;pheno&quot;, &quot;GWAS.ega_phenotypes&quot;) DSI::datashield.assign.expr(conns = conns, symbol = &quot;pheno_object&quot;, expr = quote(as.resource.data.frame(pheno))) We can follow the same analogy as before to know that we have assigned the phenotypes table to a variable called pheno_object on the remote R session. ds.class(&quot;pheno_object&quot;) $cohort1 [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; We can also check the column names to see which information is present on the table. ds.colnames(&quot;pheno_object&quot;)[[1]] [1] &quot;age_cancer_diagnosis&quot; &quot;age_recruitment&quot; [3] &quot;alcohol_day&quot; &quot;basophill_count&quot; [5] &quot;behaviour_tumour&quot; &quot;bmi&quot; [7] &quot;c_reactive_protein_reportability&quot; &quot;record_origin&quot; [9] &quot;report_format&quot; &quot;cholesterol&quot; [11] &quot;birth_country&quot; &quot;actual_tobacco_smoker&quot; [13] &quot;date_diagnosis&quot; &quot;diabetes_diagnosed_doctor&quot; [15] &quot;diastolic_blood_pressure&quot; &quot;duration_moderate_activity&quot; [17] &quot;duration_vigorous_activity&quot; &quot;energy&quot; [19] &quot;eosinophill_count&quot; &quot;ethnicity&quot; [21] &quot;ever_smoked&quot; &quot;fasting_time&quot; [23] &quot;alcohol_frequency&quot; &quot;hdl_cholesterol&quot; [25] &quot;hip_circumference&quot; &quot;histology_tumour&quot; [27] &quot;home_e_coordinate&quot; &quot;home_n_coordinate&quot; [29] &quot;e_house_score&quot; &quot;s_house_score&quot; [31] &quot;w_house_score&quot; &quot;e_income_score&quot; [33] &quot;w_income_score&quot; &quot;ldl_direct&quot; [35] &quot;lymphocyte_count&quot; &quot;monocyte_count&quot; [37] &quot;neutrophill_count&quot; &quot;n_accidental_death_close_gen_family&quot; [39] &quot;household_count&quot; &quot;children_count&quot; [41] &quot;operations_count&quot; &quot;operative_procedures&quot; [43] &quot;past_tobacco&quot; &quot;platelet_count&quot; [45] &quot;pulse_rate&quot; &quot;qualification&quot; [47] &quot;cancer_occurrences&quot; &quot;reticulocuyte_count&quot; [49] &quot;sleep_duration&quot; &quot;height&quot; [51] &quot;subject_id&quot; &quot;triglycerides&quot; [53] &quot;cancer_type_idc10&quot; &quot;cancer_type_idc9&quot; [55] &quot;weight&quot; &quot;leukocyte_count&quot; [57] &quot;sex&quot; &quot;phenotype&quot; [59] &quot;age_death&quot; &quot;age_diagnosis_diabetes&quot; [61] &quot;date_k85_report&quot; &quot;date_k86_report&quot; [63] &quot;date_death&quot; &quot;enm_diseases&quot; [65] &quot;source_k85_report&quot; &quot;source_k86_report&quot; [67] &quot;age_hbp_diagnosis&quot; &quot;mental_disorders&quot; [69] &quot;respiratory_disorders&quot; &quot;cancer_year&quot; [71] &quot;circulatory_disorders&quot; &quot;digestive_disorders&quot; [73] &quot;nervous_disorders&quot; &quot;immune_disorders&quot; 3.1.4 Merge VCF (genotype) and phenotype information Arrived at this point, we have 21 VCF objects (each one corresponds to a chromosome) and a phenotypes table on our remote session. The next step is merging each of the VCF objects with the phenotypes table. Before doing that however, we have to gather some information from the phenotypes table. The information to gather is summarized on the Table 3.2. Table 3.2: Information to gather from the phenotypes table. Information Details Which column has the samples identifier? Column name that contains the IDs of the samples. Those are the IDs that will be matched to the ones present on the VCF objects. Which is the sex column on the covariates file? Column name that contains the sex information. How are males and how are females encoded into this column? There is not a standard way to encode the sex information, some people use 0/1; male/female; etc. Our approach uses a library that requires a specific encoding, for that reason we need to know the original encoding to perform the translation. Which is the case-control column? Column name that contains the case/control to be studied. What is the encoding for case and for control on this column? Similar as the sex column, the case/control will be translated to the particular standard of the software we have used to develop our functionalities3 . If we are not sure about the exact column names, we can use the function ds.colnames as we did before. Also, we can use the function ds.table1D to check the level names of the categorical variables. ds.table1D(&quot;pheno_object$sex&quot;)$counts pheno_object$sex female 1271 male 1233 Total 2504 ds.table1D(&quot;pheno_object$diabetes_diagnosed_doctor&quot;)$counts pheno_object$diabetes_diagnosed_doctor Do_not_know 612 No 632 Prefer_not_to_answer 590 Yes 668 Total 2502 From the different functions we used, we can extract our answers (Summarized on the Table 3.3) Table 3.3: Summary of options from the example phenotypes table. Question Answer Which column has the samples identifier? subject_id Which is the sex column on the covariates file? sex How are males and how are females encoded into this column? male/female Which is the case-control column of interest of the covariates? diabetes_diagnosed_doctor What is the encoding for case and for control on this column? Yes/No With all this information we can now merge the phenotypes and VCF objects into a type of object named GenotypeData. We will use the ds.GenotypeData function. lapply(1:21, function(x){ ds.GenotypeData(x=paste0(&#39;gds&#39;, x,&#39;_object&#39;), covars = &#39;pheno_object&#39;, columnId = &quot;subject_id&quot;, sexId = &quot;sex&quot;, male_encoding = &quot;male&quot;, female_encoding = &quot;female&quot;, case_control_column = &quot;diabetes_diagnosed_doctor&quot;, case = &quot;Yes&quot;, control = &quot;No&quot;, newobj.name = paste0(&#39;gds.Data&#39;, x), datasources = conns) }) The objects we just created are named gds.DataXX on the remote session. Now we are ready to perform a GWAS analysis. To perform a GWAS we have to supply this Genotype Data objects and some sort of formula in which we will specify the type of association we are interested on studying. The R language has its own way of writing formulas, a simple example would be the following (relate the condition to the smoke variable adjusted by sex): condition ~ smoke + sex For this use case we will use the following formula. diabetes_diagnosed_doctor ~ sex + hdl_cholesterol 3.1.5 Performing the GWAS We are finally ready to achieve our ultimate goal, performing a GWAS analysis. We have our data (genotype + phenotypes) organized into the correspondent objects (GenotypeData) and our association formula ready. The function ds.metaGWAS is in charge of doing the analysis, we have to supply it with the names of the GenotypeData objects of the remote R session and the formula. Since we have 21 different objects, the paste0 function is used to simplify the call. results_single &lt;- ds.metaGWAS(genoData = paste0(&quot;gds.Data&quot;, 1:21), model = diabetes_diagnosed_doctor ~ sex + hdl_cholesterol)[[1]] results_single # A tibble: 865,240 x 10 rs chr pos n.obs freq p.value Est Est.SE reference_allele * &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 rs4648446 1 2.89e6 1292 0.512 7.42e-6 -0.323 0.0721 C 2 rs4659014 1 1.20e8 1296 0.587 8.74e-6 0.321 0.0723 T 3 rs127465~ 1 2.90e6 1294 0.548 9.69e-6 -0.321 0.0725 C 4 rs313728 1 8.62e7 1293 0.277 1.08e-5 -0.375 0.0852 C 5 rs113272~ 1 1.17e8 1292 0.859 1.08e-5 -0.459 0.104 T 6 rs173625~ 1 2.82e7 1293 0.864 2.26e-5 -0.466 0.110 C 7 rs292001 1 2.30e7 1293 0.343 2.64e-5 0.327 0.0779 G 8 rs741198~ 1 1.47e8 1294 0.932 3.16e-5 0.608 0.146 A 9 rs580006~ 1 5.30e7 1293 0.929 3.69e-5 0.590 0.143 C 10 rs729056~ 1 5.30e7 1294 0.929 4.18e-5 0.586 0.143 G # ... with 865,230 more rows, and 1 more variable: alternate_allele &lt;chr&gt; We can display the results of the GWAS using a Manhattan plot. manhattan(results_single) (#fig:singleCohortManhattan_plot)Manhattan plot of the single-cohort results. Moreover, we can visualize the region with the lowest p-value in detail using the function LocusZoom. There are multiple arguments to control the gene annotation, display a different region of the GWAS, display a different range of positions and more. Make sure to check ?LocusZoom for all the details. LocusZoom(results_single, use_biomaRt = FALSE) Figure 3.2: LocusZoom plot of the surrounding region of the top hit SNP. datashield.logout(conns) 3.2 Multi cohorts  RESOURCES USED ALONG THIS SECTION From https://opal-demo.obiba.org/ : STUDY TABLE PROFILE cohort1 GWAS.chr{1..21}A omics cohort2 GWAS.chr{1..21}B omics cohort3 GWAS.chr{1..21}C omics cohort1 GWAS.ega_phenotypes_1 omics cohort2 GWAS.ega_phenotypes_2 omics cohort3 GWAS.ega_phenotypes_3 omics Now all the individuals used for the single cohort use case will be divided into three different synthetic cohorts. The results from each cohort will then be meta-analyzed to be compared to the results obtained by studying all the individuals together. As with the single-cohort methodology illustrated on the prior section, this method guarantees GDPR data confidentiality. The structure for a three cohort study is illustrated on the following figure (note this can be extrapolated for cohorts with a bigger (or lower) partner count). Figure 3.3: Proposed infrastructure to perform multi-cohort GWAS studies. The data analyst corresponds to the RStudio session, which through DataSHIELD Interface (DSI) connects with the Opal server located at the cohort network. This Opal server contains an array of resources that correspond to the different VCF files (sliced by chromosome)4 and a resource that corresponds to the phenotypes table of the studied individuals. This use case will portray a complete study methodology, more precisely we will follow this flowchart: Figure 3.4: Flowchart to perform multi-cohort GWAS studies. Adapted from Winkler et al. (2014) Brief description of each step: Step 1: Logging into the Opal servers and load all the VCF files to the remote R sessions. Corresponds to the sections Connection to the Opal server, Assign the VCF resources, Assign the phenotypes and Merge VCF (genotype) and phenotype information. Step 2: Performing a GWAS analysis on each cohort and collect all the aggregated non-disclosive statistics. Corresponds to the sections Performing the GWAS and GWAS Plots. Step 3: Apply different QC control methodologies to assess possible problems on the data used on each cohort to perform the analysis. Corresponds to the section Meta-level quality control. Step 4: Perform the meta-analysis of the aggregated statistics. Corresponds to the section Meta-analysis. Step 5: Perform a pooled ultra fast GWAS and compare the results to the ones of the meta-analysis. Corresponds to the section Ultra fast GWAS. Step 6: Perform post-omics analysis: Enrichment analysis. Corresponds to the section Post-omic analysis. 3.2.1 Connection to the Opal server We have to create an Opal connection object to the different cohorts server. We do that using the following functions. require(&#39;DSI&#39;) require(&#39;DSOpal&#39;) require(&#39;dsBaseClient&#39;) require(&#39;dsOmicsClient&#39;) builder &lt;- DSI::newDSLoginBuilder() builder$append(server = &quot;cohort1&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) builder$append(server = &quot;cohort2&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) builder$append(server = &quot;cohort3&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) logindata &lt;- builder$build() conns &lt;- DSI::datashield.login(logins = logindata) It is important to note that in this use case, we are only using one server that contains all the resources (https://opal-demo.obiba.org/), on this server there are all the resources that correspond to the different cohorts. On a more real scenario each one of the builder$append instructions would be connecting to a different server. 3.2.2 Assign the VCF resources Now that we have created a connection object to the different Opals, we have started three R session, our analysis will take place on those remote sessions, so we have to load the data into them. In this use case we will use 63 different resources from the GWAS project hosted on the demo Opal server. This resources correspond to VCF files with information on individual chromosomes (21 chromosomes per three cohorts). The names of the resources are chrXXY (where XX is the chromosome number and Y is the cohort A/B/C). Following the Opal syntax, we will refer to them using the string GWAS.chrXXY. We have to refer specifically to each different server by using conns[X], this allows us to communicate with the server of interest to indicate to it the resources that it has to load. # Cohort 1 resources lapply(1:21, function(x){ DSI::datashield.assign.resource(conns[1], paste0(&quot;chr&quot;, x), paste0(&quot;GWAS.chr&quot;, x,&quot;A&quot;)) }) # Cohort 2 resources lapply(1:21, function(x){ DSI::datashield.assign.resource(conns[2], paste0(&quot;chr&quot;, x), paste0(&quot;GWAS.chr&quot;, x,&quot;B&quot;)) }) # Cohort 3 resources lapply(1:21, function(x){ DSI::datashield.assign.resource(conns[3], paste0(&quot;chr&quot;, x), paste0(&quot;GWAS.chr&quot;, x,&quot;C&quot;)) }) Now we have assigned all the resources named GWAS.chrXXY into our remote R session. We have assigned them to the variables called chrXX. To verify this step has been performed correctly, we could use the ds.class function to check for their class and that they exist on the remote sessions. ds.class(&quot;chr1&quot;) $cohort1 [1] &quot;GDSFileResourceClient&quot; &quot;FileResourceClient&quot; &quot;ResourceClient&quot; [4] &quot;R6&quot; $cohort2 [1] &quot;GDSFileResourceClient&quot; &quot;FileResourceClient&quot; &quot;ResourceClient&quot; [4] &quot;R6&quot; $cohort3 [1] &quot;GDSFileResourceClient&quot; &quot;FileResourceClient&quot; &quot;ResourceClient&quot; [4] &quot;R6&quot; We can see that the object chr1 exists in all the three servers. Finally the resources are resolved to retrieve the data in the remote sessions. lapply(1:21, function(x){ DSI::datashield.assign.expr(conns = conns, symbol = paste0(&quot;gds&quot;, x, &quot;_object&quot;), expr = as.symbol(paste0(&quot;as.resource.object(chr&quot;, x, &quot;)&quot;))) }) Now we have resolved the resources named chrXX into our remote R sessions. The objects retrieved have been assigned into variables named gdsXX_object. We can check the process was successful as we did before. ds.class(&quot;gds1_object&quot;) $cohort1 [1] &quot;GdsGenotypeReader&quot; attr(,&quot;package&quot;) [1] &quot;GWASTools&quot; $cohort2 [1] &quot;GdsGenotypeReader&quot; attr(,&quot;package&quot;) [1] &quot;GWASTools&quot; $cohort3 [1] &quot;GdsGenotypeReader&quot; attr(,&quot;package&quot;) [1] &quot;GWASTools&quot; 3.2.3 Assign the phenotypes The objects we have loaded into our remote sessions are VCF files that contain genomic information of the individuals. To perform a GWAS this information has to be related to some phenotypes to extract relationships. Therefore, we need to load the phenotypes into the remote sessions. The phenotypes information is a table that contains the individuals as rows and phenotypes as columns. In this use case, we will use a resource (as with the VCF files) to load the phenotypes table into the remote sessions. As with the VCF resources, here we load a different resource to each cohort, as it is expected that each cohort has only the phenotypes information regarding their individuals, therefore different tables. Note that we are assigning the resource to the same variable at each server (pheno), so we only need one function call to resolve all the resources together. # Cohort 1 phenotypes table DSI::datashield.assign.resource(conns[1], &quot;pheno&quot;, &quot;GWAS.ega_phenotypes_1&quot;) # Cohort 2 phenotypes table DSI::datashield.assign.resource(conns[2], &quot;pheno&quot;, &quot;GWAS.ega_phenotypes_2&quot;) # Cohort 3 phenotypes table DSI::datashield.assign.resource(conns[3], &quot;pheno&quot;, &quot;GWAS.ega_phenotypes_3&quot;) # Resolve phenotypes table DSI::datashield.assign.expr(conns = conns, symbol = &quot;pheno_object&quot;, expr = quote(as.resource.data.frame(pheno))) We can follow the same analogy as before to know that we have assigned the phenotypes table to a variable called pheno_object on the remote R session. ds.class(&quot;pheno_object&quot;) $cohort1 [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; $cohort2 [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; $cohort3 [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; We can also check the column names to see which information is present on the table. ds.colnames(&quot;pheno_object&quot;)[[1]] [1] &quot;age_cancer_diagnosis&quot; &quot;age_recruitment&quot; [3] &quot;alcohol_day&quot; &quot;basophill_count&quot; [5] &quot;behaviour_tumour&quot; &quot;bmi&quot; [7] &quot;c_reactive_protein_reportability&quot; &quot;record_origin&quot; [9] &quot;report_format&quot; &quot;cholesterol&quot; [11] &quot;birth_country&quot; &quot;actual_tobacco_smoker&quot; [13] &quot;date_diagnosis&quot; &quot;diabetes_diagnosed_doctor&quot; [15] &quot;diastolic_blood_pressure&quot; &quot;duration_moderate_activity&quot; [17] &quot;duration_vigorous_activity&quot; &quot;energy&quot; [19] &quot;eosinophill_count&quot; &quot;ethnicity&quot; [21] &quot;ever_smoked&quot; &quot;fasting_time&quot; [23] &quot;alcohol_frequency&quot; &quot;hdl_cholesterol&quot; [25] &quot;hip_circumference&quot; &quot;histology_tumour&quot; [27] &quot;home_e_coordinate&quot; &quot;home_n_coordinate&quot; [29] &quot;e_house_score&quot; &quot;s_house_score&quot; [31] &quot;w_house_score&quot; &quot;e_income_score&quot; [33] &quot;w_income_score&quot; &quot;ldl_direct&quot; [35] &quot;lymphocyte_count&quot; &quot;monocyte_count&quot; [37] &quot;neutrophill_count&quot; &quot;n_accidental_death_close_gen_family&quot; [39] &quot;household_count&quot; &quot;children_count&quot; [41] &quot;operations_count&quot; &quot;operative_procedures&quot; [43] &quot;past_tobacco&quot; &quot;platelet_count&quot; [45] &quot;pulse_rate&quot; &quot;qualification&quot; [47] &quot;cancer_occurrences&quot; &quot;reticulocuyte_count&quot; [49] &quot;sleep_duration&quot; &quot;height&quot; [51] &quot;subject_id&quot; &quot;triglycerides&quot; [53] &quot;cancer_type_idc10&quot; &quot;cancer_type_idc9&quot; [55] &quot;weight&quot; &quot;leukocyte_count&quot; [57] &quot;sex&quot; &quot;phenotype&quot; [59] &quot;age_death&quot; &quot;age_diagnosis_diabetes&quot; [61] &quot;date_k85_report&quot; &quot;date_k86_report&quot; [63] &quot;date_death&quot; &quot;enm_diseases&quot; [65] &quot;source_k85_report&quot; &quot;source_k86_report&quot; [67] &quot;age_hbp_diagnosis&quot; &quot;mental_disorders&quot; [69] &quot;respiratory_disorders&quot; &quot;cancer_year&quot; [71] &quot;circulatory_disorders&quot; &quot;digestive_disorders&quot; [73] &quot;nervous_disorders&quot; &quot;immune_disorders&quot; 3.2.4 Merge VCF (genotype) and phenotype information Arrived at this point, we have 21 VCF objects at each cohort R session (each one corresponds to a chromosome) and a phenotypes table. The next step is merging each of the VCF objects with the phenotypes table. The same procedure as the single cohort can be applied to extract the arguments required. With all this information we can now merge the phenotypes and VCF objects into a type of object named GenotypeData. We will use the ds.GenotypeData function. lapply(1:21, function(x){ ds.GenotypeData(x=paste0(&#39;gds&#39;, x,&#39;_object&#39;), covars = &#39;pheno_object&#39;, columnId = &quot;subject_id&quot;, sexId = &quot;sex&quot;, male_encoding = &quot;male&quot;, female_encoding = &quot;female&quot;, case_control_column = &quot;diabetes_diagnosed_doctor&quot;, case = &quot;Yes&quot;, control = &quot;No&quot;, newobj.name = paste0(&#39;gds.Data&#39;, x), datasources = conns) }) The objects we just created are named gds.DataXX on the remote session. Now we are ready to perform a GWAS analysis. We will use the same formula as the single cohort use case to be able to compare the results later: diabetes_diagnosed_doctor ~ sex + hdl_cholesterol 3.2.5 Performing a meta - GWAS We now proceed to perform the GWAS analysis. results &lt;- ds.metaGWAS(genoData = paste0(&quot;gds.Data&quot;, 1:21), model = diabetes_diagnosed_doctor ~ sex + hdl_cholesterol) And we can see the results for each cohort. Cohort 1 Cohort 2 Cohort 3  # A tibble: 865,162 x 10 rs chr pos n.obs freq p.value Est Est.SE reference_allele * &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 rs579533~ 1 3.90e7 430 0.737 3.28e-7 0.730 0.143 T 2 rs113272~ 1 1.17e8 428 0.876 6.44e-7 -0.936 0.188 T 3 rs4970551 1 3.90e7 350 0.749 6.02e-6 0.738 0.163 A 4 rs9726184 1 2.81e7 430 0.801 6.50e-6 0.702 0.156 C 5 rs2906466 1 4.43e7 428 0.551 8.79e-6 -0.563 0.127 A 6 rs121172~ 1 1.87e8 428 0.407 8.87e-6 -0.600 0.135 T 7 rs1626710 1 2.06e8 428 0.215 1.06e-5 -0.693 0.157 C 8 rs109026~ 1 2.81e7 430 0.8 1.10e-5 0.679 0.155 G 9 rs1938519 1 1.87e8 429 0.597 1.24e-5 0.587 0.134 A 10 rs1572823 1 1.99e7 428 0.189 1.24e-5 -0.740 0.169 T # ... with 865,152 more rows, and 1 more variable: alternate_allele &lt;chr&gt;  # A tibble: 865,190 x 10 rs chr pos n.obs freq p.value Est Est.SE reference_allele * &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 rs9426275 1 2.98e7 549 0.756 5.07e-6 -0.666 0.146 C 2 rs124057~ 1 8.57e7 549 0.934 9.05e-5 0.917 0.234 A 3 rs2762766 1 1.45e8 550 0.52 1.11e-4 1.18 0.305 T 4 rs111615~ 1 8.58e7 549 0.779 1.80e-4 0.522 0.139 T 5 rs4657641 1 1.67e8 552 0.343 2.54e-4 -0.416 0.114 G 6 rs2295623 1 1.60e8 549 0.906 2.96e-4 0.715 0.197 C 7 rs1891510 1 1.16e8 550 0.725 2.97e-4 0.499 0.138 T 8 rs776826~ 1 2.21e8 551 0.928 3.06e-4 -0.802 0.222 C 9 rs120926~ 1 3.13e7 551 0.819 3.68e-4 -0.546 0.153 C 10 rs6670319 1 1.16e8 552 0.724 3.99e-4 0.488 0.138 T # ... with 865,180 more rows, and 1 more variable: alternate_allele &lt;chr&gt;  # A tibble: 849,560 x 10 rs chr pos n.obs freq p.value Est Est.SE reference_allele * &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 rs4915771 1 62151742 285 0.593 2.77e-5 -0.700 0.167 G 2 rs7544580 1 62178523 285 0.593 2.77e-5 -0.700 0.167 T 3 rs1385117 1 102112168 286 0.893 3.81e-5 1.09 0.264 A 4 rs121437~ 1 172319486 285 0.909 4.07e-5 1.16 0.283 T 5 rs7521871 1 102110628 285 0.893 4.19e-5 1.08 0.264 G 6 rs133739~ 1 102113861 285 0.893 4.19e-5 1.08 0.264 A 7 rs600511~ 1 245057001 286 0.893 6.36e-5 1.08 0.271 T 8 rs1938514 1 187349937 285 0.760 8.05e-5 -0.746 0.189 C 9 rs121309~ 1 172358588 285 0.919 8.18e-5 1.16 0.295 G 10 rs761675~ 1 172361011 285 0.919 8.18e-5 1.16 0.295 G # ... with 849,550 more rows, and 1 more variable: alternate_allele &lt;chr&gt; 3.2.6 GWAS Plots We can display the results of the GWAS using a Manhattan plot for each cohort. Cohort 1 Cohort 2 Cohort 3  manhattan(results[[1]]) Figure 3.5: Manhattan plot of the Cohort 1.  manhattan(results[[2]]) Figure 3.6: Manhattan plot of the Cohort 1.  manhattan(results[[3]]) Figure 3.7: Manhattan plot of the Cohort 1. 3.2.7 Meta-level quality control Up to this point we have collected the aggregated statistics from each cohort and we have visualized them. Before meta-analyzing this statistics we have to perform some quality control to make sure there are no major issues. There are three different methods bundled in dsOmicsClient to perform such task: EAF Plot: Plotting the reported EAFs against a reference set, such as from the HapMap or 1000 Genomes projects, or from one specific study, can help visualize patterns that pinpoint strand issues, allele miscoding or the inclusion of individuals whose self-reported ancestry did not match their genetic ancestry. P-Z Plot: Plot to reveal issues with beta estimates, standard errors and P values. The plots compare P values reported in the association GWAS with P values calculated from Z-statistics (P.ztest) derived from the reported beta and standard error. A study with no issues should show perfect concordance. It will generate a plot per study, where concordance of all the study SNPs will be displayed. SE-N Plot: Plot to reveal issues with trait transformations. A collection of studies with no issues will fall on a line. If any of these QC raises some inconsistencies, please contact the correspondent study analyst. 3.2.7.1 EAF Plot For this plot we are comparing the estimated allele frequencies to a reference set, so the first step is to get ourselves a reference set. For this example we will be using the ALL.wgs.phase1_release_v3.20101123 reference set. We will download it and load it into the client R session. reference &lt;- readr::read_tsv(&quot;https://homepages.uni-regensburg.de/~wit59712/easyqc/exomechip/ALL.wgs.phase1_release_v3.20101123.snps_indels_sv.sites.EUR_AF.txt.exm.tab.sexChr.DI.txt.GZ&quot;) reference # A tibble: 75,292 x 8 ExmName chrChr_Pos Chr Pos Rs Ref Alt Freq &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; 1 exm2268640 chr1:762320 1 762320 rs75333668 C T 0.0013 2 exm47 chr1:865628 1 865628 rs41285790 G A 0.01 3 exm55 chr1:865694 1 865694 rs9988179 C T 0.0026 4 exm67 chr1:871159 1 871159 . G A 0.0013 5 exm106 chr1:874762 1 874762 rs139437968 C T 0.0013 6 exm158 chr1:878744 1 878744 . G C 0.0026 7 exm241 chr1:880502 1 880502 rs74047418 C T 0.0013 8 exm2253575 chr1:881627 1 881627 rs2272757 G A 0.63 9 exm269 chr1:881918 1 881918 rs35471880 G A 0.06 10 exm340 chr1:888659 1 888659 rs3748597 T C 0.95 # ... with 75,282 more rows Now we just use the function eafPlot and we pass to it the GWAS results and the reference set. eafPlot(x = results, reference = reference, rs_reference = &quot;Rs&quot;, freq_reference = &quot;Freq&quot;) Figure 3.8: EAF Plot. The obtained results are the expected, which is a linear correlation of slope one. This indicates the alleles are correctly encoded. For further explanation on how to assess the results produced by this plot, please refer to the Figure 4 of Winkler et al. (2014). 3.2.7.2 P-Z Plot This plot will assess the issues with beta estimates, standard errors and P values. Here we will only need the results from the ds.GWAS function and pass them to the function pzPlot. pzPlot(results) Figure 3.9: P-Z Plot. Please note that all the SNPs are plotted, for that reason there may be some performance issues if there are many SNPs to be plotted. A dataset with no issues will show perfect concordance. For further details please refer to the Figure 3 of Winkler et al. (2014). 3.2.7.3 SE-N Plot Finally, we will assess issues with trait transformations. For this we will only need the results from the ds.GWAS function and pass them to the function seNPlot. seNPlot(results) Figure 3.10: SE-N Plot. If all the study points fall on a line, no issues are present. For further detail please refer to the Figure 2 of Winkler et al. (2014). 3.2.8 Meta-analysis Given no problems have been detected on the meta-level QC, we will proceed. Up to this point, we have obtained association results for each cohort on the study. The next step is to combine this information using meta-analysis methods to derive a pooled estimate. Each researcher might have an already built pipeline to do so, or a preferred method; nevertheless, we included a couple methods inside dsOmicsClient. They are the following: Meta-analysis of p-values: Using the sum of logs method (Fishers method). Meta-analysis of beta values: Using a fixed-effects model. Methodology extracted and adapted from Pirinen (2020). 3.2.8.1 Assessment of the meta-analysis methods Previously, we have calculated the same GWAS analysis both using all the individuals and a simulated three-cohort scenario. This gives us the ability to assess how good or bad are the different meta-analysis methods; to do so, we will compare both meta-analysis to the complete data, the evaluation method will be counting the number of top hits that match, more specifically we will search for matches on the top twenty hits. We apply both methods to the multi-cohort use case results: meta_pvalues &lt;- metaPvalues(results) meta_bvalues &lt;- metaBetaValues(results) We can now compare the 20 top hits from the complete data (previously stored on the variable results_single) to the 20 top hits yielded by both meta-analysis methodologies. # Extract 20 top hits for all three cases # All individuals top_20_complete &lt;- results_single %&gt;% arrange(p.value) %&gt;% head(20) # Pvalue meta-analysis top_20_pval &lt;- meta_pvalues %&gt;% arrange(p.meta) %&gt;% head(20) # Beta meta-analysis top_20_beta &lt;- meta_bvalues %&gt;% arrange(pval) %&gt;% head(20) # Number of hits shared by all individuals case and beta meta-analysis sum(top_20_complete$rs %in% top_20_beta$rs) [1] 13 # Number of hits shared by all individuals case and pvalue meta-analysis sum(top_20_complete$rs %in% top_20_pval$rs) [1] 1 The meta-analysis using beta values recovers a higher amount of top SNPs, therefore it can be considerate a more powerful method for GWAS meta-analyses. 3.2.8.2 Visualizing the results of the meta-analysis We can use the manhattan plot and locus zoom to visualize the results of the meta-analysis as we visualized the single cohorts before. To help assess the meta-analysis behaviour, we will plot together the meta-analysis results and the complete data results. 3.2.8.2.1 Manhatan plot Meta-analysis Complete data  manhattan(meta_bvalues) Figure 3.11: Manhattan plot of the meta-analysis results.  manhattan(results_single) Figure 3.12: Manhattan plot of the complete data. 3.2.8.2.2 LocusZoom Meta-analysis Complete data  LocusZoom(meta_bvalues, pvalue = &quot;p.F&quot;, use_biomaRt = FALSE) Figure 3.13: LocusZoom plot of the meta-analysis results.  LocusZoom(results_single, use_biomaRt = FALSE) Figure 3.14: LocusZoom plot of the complete data. 3.2.8.3 Meta-analysis versus pooled linear models The dsOmicsClient package also bundles a function to fit pooled generalized linear models (GLM) on single (or multiple) SNPs. On this section we will compare the results of the meta-analysis to the pooled GLM models to see which method is more accurate. The meta-analysis method will be the beta values (fixed-effects model). The study methodology will be similar to the one we just performed. The top 20 hits yielded by the meta-analysis will be selected, those SNPs will be studied using the pooled GLM function. Both results will be compared to the complete data. We aim to replicate a real scenario with this study, typically there is no access to the complete data (if so there is no point on performing meta-analysis on synthetic multi-cohorts), therefore we simulate the discovery of SNPs of interest via meta-analysis, then we want to assess if studying individually those SNPs using pooled GLM will put us closer to the results yielded by having the complete data. We have already calculated the top 20 SNPs discovered by the beta meta-analysis. top_20_beta # A tibble: 20 x 10 rs chr pos b.F se.F p.F OR low up pval &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 rs124597~ 19 4.51e7 -0.530 0.0988 8.23e-8 0.589 0.485 0.714 8.23e-8 2 rs956025 12 1.19e8 -0.406 0.0850 1.82e-6 0.667 0.564 0.787 1.82e-6 3 rs8130070 21 4.57e7 0.398 0.0846 2.51e-6 1.49 1.26 1.76 2.51e-6 4 rs8130914 21 4.68e7 -0.879 0.192 4.41e-6 0.415 0.285 0.604 4.41e-6 5 rs9980256 21 4.24e7 -0.389 0.0852 4.92e-6 0.677 0.573 0.801 4.92e-6 6 rs177569~ 14 6.92e7 -0.613 0.134 5.19e-6 0.542 0.416 0.705 5.19e-6 7 rs112352~ 10 9.88e7 0.766 0.169 6.05e-6 2.15 1.54 3.00 6.05e-6 8 rs721891 19 5.23e7 -0.491 0.109 6.11e-6 0.612 0.494 0.757 6.11e-6 9 rs124233~ 12 1.24e7 0.710 0.158 6.77e-6 2.03 1.49 2.77 6.77e-6 10 rs9722322 9 2.79e7 0.345 0.0771 7.49e-6 1.41 1.21 1.64 7.49e-6 11 rs122370~ 9 1.72e7 0.499 0.111 7.50e-6 1.65 1.32 2.05 7.50e-6 12 rs169114~ 10 5.97e7 0.681 0.152 7.74e-6 1.97 1.47 2.66 7.74e-6 13 rs7714862 5 2.39e7 0.375 0.0842 8.30e-6 1.46 1.23 1.72 8.30e-6 14 rs8066656 17 7.65e7 -0.551 0.124 9.28e-6 0.576 0.452 0.735 9.28e-6 15 rs101939~ 2 1.39e8 -0.439 0.0992 9.60e-6 0.645 0.531 0.783 9.60e-6 16 rs101853~ 2 1.39e8 -0.409 0.0927 9.99e-6 0.664 0.554 0.796 9.99e-6 17 rs109558~ 8 1.19e8 -0.333 0.0754 1.01e-5 0.717 0.618 0.831 1.01e-5 18 rs581815 2 2.25e8 -0.343 0.0778 1.06e-5 0.710 0.609 0.827 1.06e-5 19 rs985355 18 2.70e7 -0.359 0.0816 1.10e-5 0.699 0.595 0.820 1.10e-5 20 rs313728 1 8.62e7 -0.389 0.0886 1.11e-5 0.677 0.569 0.806 1.11e-5 Next, we have to fit pooled GLM using the ds.glmSNP function, obviously we have to fit the same model that we did on the GWAS (Diabetes.diagnosed.by.doctor ~ sex + HDL.cholesterol), otherwise the results will not be consistent. The ds.glmSNP function is an extension of the dsBaseClient::ds.glm function, therefore it offers pooled analysis capabilities and disclosure controls. Remember that we have the genotype data separated by chromosome, following that we will construct the GLM calls as follows: s &lt;- lapply(1:nrow(top_20_beta), function(x){ tryCatch({ ds.glmSNP(snps.fit = top_20_beta[x, 1], model = diabetes_diagnosed_doctor ~ sex + hdl_cholesterol, genoData = paste0(&quot;gds.Data&quot;, top_20_beta[x, 2])) }, error = function(w){NULL}) }) # Simple data cleaning and column name changes ss &lt;- data.frame(do.call(rbind, s)) ss &lt;- ss %&gt;% rownames_to_column(&quot;rs&quot;) pooled &lt;- ss %&gt;% dplyr::rename(Est.pooled = Estimate, SE.pooled = Std..Error, pval.pooled = p.value) %&gt;% dplyr::select(-c(n, p.adj)) We now extract the results of interest from the meta-analysis and the complete data. # Get data from all individuals study original &lt;- results_single %&gt;% dplyr::rename(pval.original = p.value, Est.original = Est, SE.original = Est.SE) %&gt;% dplyr::select(c(rs, Est.original, SE.original, pval.original)) # Arrange dadta from beta meta-analysis beta &lt;- top_20_beta %&gt;% dplyr::rename(pval.beta = pval, Est.beta = b.F, SE.beta = se.F) %&gt;% dplyr::select(c(rs, Est.beta, SE.beta, pval.beta)) # Merge all data on a single table total &lt;- Reduce(function(x,y){inner_join(x,y, by = &quot;rs&quot;)}, list(original, pooled, beta)) With all the information gathered we can visualize the results on the Table 4. Table 4: Beta values, standard errors and p-values yielded by the three methods: GWAS of all individuals, meta-analysis of synthetic cohorts, pooled analysis of synthetic cohorts. html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #ivktjyghtx .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 10pt; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #ivktjyghtx .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ivktjyghtx .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #ivktjyghtx .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #ivktjyghtx .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ivktjyghtx .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ivktjyghtx .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #ivktjyghtx .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #ivktjyghtx .gt_column_spanner_outer:first-child { padding-left: 0; } #ivktjyghtx .gt_column_spanner_outer:last-child { padding-right: 0; } #ivktjyghtx .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #ivktjyghtx .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #ivktjyghtx .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #ivktjyghtx .gt_from_md > :first-child { margin-top: 0; } #ivktjyghtx .gt_from_md > :last-child { margin-bottom: 0; } #ivktjyghtx .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #ivktjyghtx .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #ivktjyghtx .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ivktjyghtx .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #ivktjyghtx .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ivktjyghtx .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #ivktjyghtx .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #ivktjyghtx .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ivktjyghtx .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ivktjyghtx .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #ivktjyghtx .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ivktjyghtx .gt_sourcenote { font-size: 90%; padding: 4px; } #ivktjyghtx .gt_left { text-align: left; } #ivktjyghtx .gt_center { text-align: center; } #ivktjyghtx .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #ivktjyghtx .gt_font_normal { font-weight: normal; } #ivktjyghtx .gt_font_bold { font-weight: bold; } #ivktjyghtx .gt_font_italic { font-style: italic; } #ivktjyghtx .gt_super { font-size: 65%; } #ivktjyghtx .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } SNP id Beta SE P-Value Original Pooled Meta Original Pooled Meta Original Pooled Meta rs313728 &minus;0.375 &minus;0.385 &minus;0.389 0.085 0.088 0.089 1.1 &times; 10&minus;5 1.2 &times; 10&minus;5 1.1 &times; 10&minus;5 rs10193985 &minus;0.444 &minus;0.446 &minus;0.439 0.098 0.101 0.099 5.5 &times; 10&minus;6 1.1 &times; 10&minus;5 9.6 &times; 10&minus;6 rs10185343 &minus;0.410 &minus;0.415 &minus;0.409 0.091 0.094 0.093 6.8 &times; 10&minus;6 1.1 &times; 10&minus;5 1.0 &times; 10&minus;5 rs581815 &minus;0.341 &minus;0.344 &minus;0.343 0.077 0.079 0.078 8.4 &times; 10&minus;6 1.2 &times; 10&minus;5 1.1 &times; 10&minus;5 rs7714862 0.376 0.371 0.375 0.081 0.084 0.084 3.2 &times; 10&minus;6 1.0 &times; 10&minus;5 8.3 &times; 10&minus;6 rs10955881 &minus;0.331 &minus;0.331 &minus;0.333 0.073 0.075 0.075 6.5 &times; 10&minus;6 1.2 &times; 10&minus;5 1.0 &times; 10&minus;5 rs9722322 0.353 0.345 0.345 0.076 0.078 0.077 3.3 &times; 10&minus;6 9.7 &times; 10&minus;6 7.5 &times; 10&minus;6 rs12237062 0.497 0.499 0.499 0.108 0.113 0.111 4.3 &times; 10&minus;6 1.1 &times; 10&minus;5 7.5 &times; 10&minus;6 rs112352624 0.685 0.814 0.766 0.160 0.186 0.169 1.9 &times; 10&minus;5 1.2 &times; 10&minus;5 6.0 &times; 10&minus;6 rs956025 &minus;0.406 &minus;0.405 &minus;0.406 0.083 0.086 0.085 9.4 &times; 10&minus;7 2.3 &times; 10&minus;6 1.8 &times; 10&minus;6 rs12423318 0.720 0.729 0.710 0.154 0.166 0.158 3.0 &times; 10&minus;6 1.1 &times; 10&minus;5 6.8 &times; 10&minus;6 rs17756914 &minus;0.621 &minus;0.639 &minus;0.613 0.133 0.141 0.134 2.8 &times; 10&minus;6 5.8 &times; 10&minus;6 5.2 &times; 10&minus;6 rs8066656 &minus;0.550 &minus;0.565 &minus;0.551 0.123 0.131 0.124 8.1 &times; 10&minus;6 1.7 &times; 10&minus;5 9.3 &times; 10&minus;6 rs985355 &minus;0.376 &minus;0.366 &minus;0.359 0.080 0.083 0.082 2.7 &times; 10&minus;6 9.7 &times; 10&minus;6 1.1 &times; 10&minus;5 rs12459712 &minus;0.510 &minus;0.528 &minus;0.530 0.096 0.101 0.099 9.9 &times; 10&minus;8 1.6 &times; 10&minus;7 8.2 &times; 10&minus;8 rs721891 &minus;0.482 &minus;0.506 &minus;0.491 0.108 0.113 0.109 8.0 &times; 10&minus;6 7.7 &times; 10&minus;6 6.1 &times; 10&minus;6 rs8130070 0.401 0.399 0.398 0.082 0.085 0.085 1.1 &times; 10&minus;6 2.8 &times; 10&minus;6 2.5 &times; 10&minus;6 rs9980256 &minus;0.392 &minus;0.388 &minus;0.389 0.082 0.086 0.085 2.0 &times; 10&minus;6 5.9 &times; 10&minus;6 4.9 &times; 10&minus;6 rs8130914 &minus;0.883 &minus;1.028 &minus;0.879 0.191 0.227 0.192 3.6 &times; 10&minus;6 5.7 &times; 10&minus;6 4.4 &times; 10&minus;6 Finally, to conclude this study we can compute the bias and mean squared error (code not shown). The results are shown on the Table 5. Table 5: Mean squared error and bias for the betas from the meta-analysis and pooled analysis compared to the complete data (all individuals). html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #wdhwxreyvw .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 10pt; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #wdhwxreyvw .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wdhwxreyvw .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #wdhwxreyvw .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #wdhwxreyvw .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wdhwxreyvw .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wdhwxreyvw .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #wdhwxreyvw .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #wdhwxreyvw .gt_column_spanner_outer:first-child { padding-left: 0; } #wdhwxreyvw .gt_column_spanner_outer:last-child { padding-right: 0; } #wdhwxreyvw .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #wdhwxreyvw .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #wdhwxreyvw .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #wdhwxreyvw .gt_from_md > :first-child { margin-top: 0; } #wdhwxreyvw .gt_from_md > :last-child { margin-bottom: 0; } #wdhwxreyvw .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #wdhwxreyvw .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #wdhwxreyvw .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wdhwxreyvw .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #wdhwxreyvw .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wdhwxreyvw .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #wdhwxreyvw .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #wdhwxreyvw .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wdhwxreyvw .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wdhwxreyvw .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #wdhwxreyvw .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wdhwxreyvw .gt_sourcenote { font-size: 90%; padding: 4px; } #wdhwxreyvw .gt_left { text-align: left; } #wdhwxreyvw .gt_center { text-align: center; } #wdhwxreyvw .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #wdhwxreyvw .gt_font_normal { font-weight: normal; } #wdhwxreyvw .gt_font_bold { font-weight: bold; } #wdhwxreyvw .gt_font_italic { font-style: italic; } #wdhwxreyvw .gt_super { font-size: 65%; } #wdhwxreyvw .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } MSE Bias Beta Pooled 2.1 &times; 10&minus;3 5.2 &times; 10&minus;3 Meta 4.2 &times; 10&minus;4 &minus;2.7 &times; 10&minus;3 With this results we can conclude that refining the statistics for the SNPs of interest using pooled GLM is advisable. Therefore the recommended flowchart when performing a GWAS using dsOmicsClient+DataSHIELD is the following: REVISAR ESTOS RESULTADOS Perform GWAS with dsOmicsClient::dsGWAS Perform meta-analysis on the results with dsOmicsClient::metaBetaValues Extract top hits from the meta-analysis. Perform pooled GLM on top hits with dsOmicsClient::ds.glmSNP 3.2.9 Ultra fast pooled GWAS analysis An alternate methodology to performing a meta analysis is to use the fast GWAS methodology. This method is named after the performance it achieves, however, it does provide further advantages other than computational speed. The main advantage is that it does not compute the results for each cohort to then be meta-analyzed, it actually computes them using a pooled technique that achieves the exact same results when all the individuals are together than when they are separated by cohorts. This is of great importance as there is no need to worry about cohort-imbalance, which is usually a problem in multi-cohort meta-analysis studies. The only downside of this method is that it does not yield the same results of a traditional GWAS analysis pipeline, the inacuraccy of the results however is really low, detailed information about that can be found on the paper that proposes the method. The performance of the function can be summarized to be ~45 seconds per 1M of SNPs (statistic extracted using 2.5k individuals divided into three study servers). From our test this performance has hold linear up to 10M SNPs, we did not test any further. The graphic for &lt; 1M SNPs can be found on the following figure. Figure 3.15: Benhmark of ds.fastGWAS function. The usage is similar to the meta-GWAS with a couple of added options, feel free to check the documentation with ?ds.fastGWAS to see information about them. results_fast &lt;- ds.fastGWAS(genoData = paste0(&quot;gds.Data&quot;, 1:21), formula = &quot;diabetes_diagnosed_doctor ~ sex + hdl_cholesterol&quot;, family = &quot;binomial&quot;, snpBlock = 5000) datashield.logout(conns) 3.2.9.1 GWAS Plot We can display the results of the fast GWAS using a Manhattan plot. manhattan(results_fast, pvalCol = 4) Figure 3.16: Manhattan plot of the Cohort 1. 3.2.9.2 Meta-analysis versus fast GWAS To finish the GWAS section we can evaluate the results of the beta meta-analysis and the results of the fast GWAS. Both methods will be compared to the ground truth. As before we can start by seeing the amount of SNPs that both methodologies recover as top hits. # Extract 20 top hits for all three cases # All individuals top_20_complete &lt;- results_single %&gt;% arrange(p.value) %&gt;% head(20) # Fast GWAS top_20_fast &lt;- results_fast %&gt;% arrange(p.value) %&gt;% head(20) # Beta meta-analysis top_20_beta &lt;- meta_bvalues %&gt;% arrange(pval) %&gt;% head(20) # Number of hits shared by all individuals case and beta meta-analysis sum(top_20_complete$rs %in% top_20_beta$rs) [1] 13 # Number of hits shared by all individuals case and fast GWAS sum(top_20_complete$rs %in% top_20_fast$rs) [1] 11 On that regard it seems the meta-analysis is performing better. We now extract the results of interest from the meta-analysis and the complete data. # Get data from all individuals study original &lt;- results_single %&gt;% dplyr::rename(pval.original = p.value, Est.original = Est, SE.original = Est.SE) %&gt;% dplyr::select(c(rs, Est.original, SE.original, pval.original)) # Arrange dadta from beta meta-analysis beta &lt;- top_20_beta %&gt;% dplyr::rename(pval.beta = pval, Est.beta = b.F, SE.beta = se.F) %&gt;% dplyr::select(c(rs, Est.beta, SE.beta, pval.beta)) # Arrange data from fast GWAS fast &lt;- top_20_fast %&gt;% dplyr::rename(pval.fast = p.value, Est.fast = Est, SE.fast = Est.SE) %&gt;% dplyr::select(c(rs, Est.fast, SE.fast, pval.fast)) # Merge all data on a single table total &lt;- Reduce(function(x,y){inner_join(x,y, by = &quot;rs&quot;)}, list(original, fast, beta)) With all the information gathered we can visualize the results on the Table 6. Table 6: Beta values, standard errors and p-values yielded by the three methods: GWAS of all individuals, meta-analysis of synthetic cohorts, fast GWAS. html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #gefziqohre .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 10pt; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #gefziqohre .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gefziqohre .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #gefziqohre .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #gefziqohre .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gefziqohre .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gefziqohre .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #gefziqohre .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #gefziqohre .gt_column_spanner_outer:first-child { padding-left: 0; } #gefziqohre .gt_column_spanner_outer:last-child { padding-right: 0; } #gefziqohre .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #gefziqohre .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #gefziqohre .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #gefziqohre .gt_from_md > :first-child { margin-top: 0; } #gefziqohre .gt_from_md > :last-child { margin-bottom: 0; } #gefziqohre .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #gefziqohre .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #gefziqohre .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gefziqohre .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #gefziqohre .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gefziqohre .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #gefziqohre .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #gefziqohre .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gefziqohre .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gefziqohre .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #gefziqohre .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gefziqohre .gt_sourcenote { font-size: 90%; padding: 4px; } #gefziqohre .gt_left { text-align: left; } #gefziqohre .gt_center { text-align: center; } #gefziqohre .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #gefziqohre .gt_font_normal { font-weight: normal; } #gefziqohre .gt_font_bold { font-weight: bold; } #gefziqohre .gt_font_italic { font-style: italic; } #gefziqohre .gt_super { font-size: 65%; } #gefziqohre .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } SNP id Beta SE P-Value Original Fast Meta Original Fast Meta Original Fast Meta rs7714862 0.376 0.380 0.375 0.081 0.082 0.084 3.2 &times; 10&minus;6 3.1 &times; 10&minus;6 8.3 &times; 10&minus;6 rs9722322 0.353 0.349 0.345 0.076 0.076 0.077 3.3 &times; 10&minus;6 4.6 &times; 10&minus;6 7.5 &times; 10&minus;6 rs12237062 0.497 0.515 0.499 0.108 0.107 0.111 4.3 &times; 10&minus;6 1.6 &times; 10&minus;6 7.5 &times; 10&minus;6 rs16911403 0.684 0.644 0.681 0.146 0.144 0.152 3.1 &times; 10&minus;6 7.3 &times; 10&minus;6 7.7 &times; 10&minus;6 rs112352624 0.685 0.732 0.766 0.160 0.157 0.169 1.9 &times; 10&minus;5 3.3 &times; 10&minus;6 6.0 &times; 10&minus;6 rs956025 &minus;0.406 &minus;0.385 &minus;0.406 0.083 0.082 0.085 9.4 &times; 10&minus;7 2.5 &times; 10&minus;6 1.8 &times; 10&minus;6 rs12423318 0.720 0.699 0.710 0.154 0.146 0.158 3.0 &times; 10&minus;6 1.8 &times; 10&minus;6 6.8 &times; 10&minus;6 rs12459712 &minus;0.510 &minus;0.521 &minus;0.530 0.096 0.094 0.099 9.9 &times; 10&minus;8 3.5 &times; 10&minus;8 8.2 &times; 10&minus;8 rs8130070 0.401 0.401 0.398 0.082 0.082 0.085 1.1 &times; 10&minus;6 1.2 &times; 10&minus;6 2.5 &times; 10&minus;6 rs9980256 &minus;0.392 &minus;0.380 &minus;0.389 0.082 0.083 0.085 2.0 &times; 10&minus;6 5.1 &times; 10&minus;6 4.9 &times; 10&minus;6 Finally, to conclude this study we can compute the bias and mean squared error (code not shown). The results are shown on the Table 7. Table 7: Mean squared error and bias for the betas from the meta-analysis and fast GWAS compared to the complete data (all individuals). html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #ecpksskndx .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 10pt; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #ecpksskndx .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ecpksskndx .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #ecpksskndx .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 6px; border-top-color: #FFFFFF; border-top-width: 0; } #ecpksskndx .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ecpksskndx .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #ecpksskndx .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #ecpksskndx .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: bold; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #ecpksskndx .gt_column_spanner_outer:first-child { padding-left: 0; } #ecpksskndx .gt_column_spanner_outer:last-child { padding-right: 0; } #ecpksskndx .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #ecpksskndx .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #ecpksskndx .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #ecpksskndx .gt_from_md > :first-child { margin-top: 0; } #ecpksskndx .gt_from_md > :last-child { margin-bottom: 0; } #ecpksskndx .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #ecpksskndx .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #ecpksskndx .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ecpksskndx .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #ecpksskndx .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #ecpksskndx .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #ecpksskndx .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #ecpksskndx .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #ecpksskndx .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ecpksskndx .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #ecpksskndx .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #ecpksskndx .gt_sourcenote { font-size: 90%; padding: 4px; } #ecpksskndx .gt_left { text-align: left; } #ecpksskndx .gt_center { text-align: center; } #ecpksskndx .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #ecpksskndx .gt_font_normal { font-weight: normal; } #ecpksskndx .gt_font_bold { font-weight: bold; } #ecpksskndx .gt_font_italic { font-style: italic; } #ecpksskndx .gt_super { font-size: 65%; } #ecpksskndx .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } MSE Bias Beta Fast 5.3 &times; 10&minus;4 &minus;2.6 &times; 10&minus;3 Meta 7.2 &times; 10&minus;4 &minus;4.2 &times; 10&minus;3 On this brief comparison weve seen that the fast GWAS retrieves sensibly less SNPs from the ground truth but it has better performance of bias and MSE. It must be noted that the data used for this GWAS examples does not suffer from any cohort imbalance, so the meta-analysis is expected to yield proper results, on a different environment the fast GWAS is expected to exceed the performance of the meta-analysis in a more remarkable manner. 3.3 Post-omic analysis Up to this point we have analyzed the genotype and phenotype data by performing a genome wide association study. We can further study the yielded results by performing an enrichment analysis. 3.3.1 Enrichment analysis The GWAS results are a collection of SNPs that displayed a relationship with a given phenotype. Those SNPs may fall inside gene regions, and those genes can be functionally related. Studying this can help researchers understand the underlying biological processes. Those analysis are carried by querying the selected gene to a database, for this example we will be using the DisGeNET database. 3.3.1.1 Annotation of genes The first step of the enrichment analysis is to annotate the genes that contain the SNPs of interest yielded by the GWAS. There are many ways to perform this step, we propose to use the biomaRt package and retrieve the annotation from the ensembl genome browser. First we select the SNPs of interest. We have established a p.value threshold to do so. snps_of_interest &lt;- results_fast %&gt;% dplyr::arrange(p.value) %&gt;% dplyr::select(chr, pos, rs, p.value) %&gt;% dplyr::filter(p.value &lt; 0.00005) And with this list of SNPs we can move to the annotation. library(biomaRt) # Perform ensembl connection gene.ensembl &lt;- useEnsembl(biomart = &quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;, GRCh = 37) # Query SNP by SNP genes_interest &lt;- Reduce(rbind, apply(snps_of_interest, 1, function(x){ result &lt;- getBM( attributes = c(&#39;entrezgene_id&#39;, &#39;chromosome_name&#39;, &#39;ensembl_gene_id&#39;, &#39;start_position&#39;, &quot;end_position&quot;), filters = c(&#39;start&#39;, &#39;end&#39;, &#39;chromosome_name&#39;), values = list(start = x[2], end = x[2], chromosome_name = x[1]), mart = gene.ensembl) })) 3.3.1.2 Enrichment analysis query Having the genes of interest annotated, the final step is to query them to DisGeNET. We will use the function enrichDGN from the package DOSE for it. This package is part of a large ecosystem of packages dedicated to enrichment analysis, this allows for easy representation of the query results. library(DOSE) enrichment &lt;- enrichDGN(unlist(genes_interest$entrezgene_id), pvalueCutoff = 0.2) 3.3.1.3 Enrichment analysis plots Here we will portray some of the visualizations that can be performed with the query results. For more information and further visualization options please read the official vignette. 3.3.1.3.1 Barplot library(enrichplot) barplot(enrichment) 3.3.1.3.2 Dotplot dotplot(enrichment) 3.3.1.3.3 CNET plot library(ggnewscale) # convert gene ID to Symbol edox &lt;- setReadable(enrichment, &#39;org.Hs.eg.db&#39;, &#39;ENTREZID&#39;) cnetplot(edox, foldChange=genes_interest$entrezgene_id) References "],["polygenic-risk-scores.html", "4 Polygenic risk scores 4.1 Definition 4.2 Study configuration 4.3 Source of polygenic scores 4.4 Connection to the Opal server 4.5 Assign the VCF resources 4.6 Calculate the PRS 4.7 Study of the PRS results", " 4 Polygenic risk scores  RESOURCES USED ALONG THIS SECTION From https://opal-demo.obiba.org/ : STUDY TABLE PROFILE cohort1 GWAS.chr{1..21}A omics cohort2 GWAS.chr{1..21}B omics cohort3 GWAS.chr{1..21}C omics cohort1 GWAS.ega_phenotypes_1 omics cohort2 GWAS.ega_phenotypes_2 omics cohort3 GWAS.ega_phenotypes_3 omics 4.1 Definition By checking for specific variants and quantifying them, a researcher can extract the polygenic risk score (PRS) of an individual, which translates to an associated risk of the individual versus a concrete phenotype. A definition of the term reads A weighted sum of the number of risk alleles carried by an individual, where the risk alleles and their weights are defined by the loci and their measured effects as detected by genome wide association studies. (Extracted from Torkamani, Wineinger, and Topol (2018)) The use of PRS markers is very popular nowadays and it has been proved to be a good tool to asses associated risks Escott-Price et al. (2017), Forgetta et al. (2020), Kramer et al. (2020). When calculating the PRS using DataSHIELD, the actual scores are not returned, as it would not be GDPR compliant to be able to determine the risk of an individual versus a certain disease. The actual results are stored on the servers and optionally can be merged to the phenotypes table. This allows further study of the PRS using summaries or fitting pooled GLM models to assess relationships between phenotypes and PRS scores. 4.2 Study configuration The PRS use case will be set up as a multi-cohort, using the same dataset as the multi-cohort GWAS (same VCF resources). A single cohort PRS could be performed analogously using the single cohort example of the GWAS. Figure 4.1: Proposed infrastructure to perform PRS studies. 4.3 Source of polygenic scores There is a public repository of polygenic scores available at https://www.pgscatalog.org/, on this website there are 2155 different polygenic scores (January 2022) that have been extracted from curated literature. All those scores refer to 526 different traits. Due the relevance of this project, we made sure to include a way of sourcing its contents automatically. There are two ways of stating the SNPs of interest and their weights in order to calculate the PRS. Provide a PGS Catalog Polygenic Score ID &amp; Name. If this option is in use, the SNPs and beta weights will be downloaded from the PGS Catalog and will be used to calculate the PRS. (Example: PGS000008) Providing a prs_table (SNPs of interest) table. The prs_table table has to have a defined structure and column names in order to be understood by this function. This table can be formulated using two schemas: Scheme 1: Provide SNP positions. Use the column names: chr_name, chr_position, effect_allele, reference_allele, effect_weight. chr_name chr_position effect_allele reference_allele effect_weight 1 100880328 T A 0.0373 1 121287994 G A -0.0673 6 152023191 A G 0.0626      Scheme 2: Provide SNP ids. Use the column names: rsID, effect_allele, reference_allele, effect_weight. rdID effect_allele reference_allele effect_weight rs11206510 T C 0.0769 rs4773144 G A 0.0676 rs17514846 A C 0.0487     The effect_weight have to be the betas (log(OR)). Please note when using a custom prs_table table that it is much faster to use the Schema 1, as the subset of the VCF files is miles faster to do using chromosome name and positions rather than SNP ids. 4.4 Connection to the Opal server We have to create an Opal connection object to the cohort server. We do that using the following functions. require(&#39;DSI&#39;) require(&#39;DSOpal&#39;) require(&#39;dsBaseClient&#39;) require(&#39;dsOmicsClient&#39;) builder &lt;- DSI::newDSLoginBuilder() builder$append(server = &quot;cohort1&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) builder$append(server = &quot;cohort2&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) builder$append(server = &quot;cohort3&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) logindata &lt;- builder$build() conns &lt;- DSI::datashield.login(logins = logindata) 4.5 Assign the VCF resources We assign the VCF and phenotypes resources. # Cohort 1 resources lapply(1:21, function(x){ DSI::datashield.assign.resource(conns[1], paste0(&quot;chr&quot;, x), paste0(&quot;GWAS.chr&quot;, x,&quot;A&quot;)) }) DSI::datashield.assign.resource(conns[1], &quot;phenotypes_resource&quot;, &quot;GWAS.ega_phenotypes_1&quot;) # Cohort 2 resources lapply(1:21, function(x){ DSI::datashield.assign.resource(conns[2], paste0(&quot;chr&quot;, x), paste0(&quot;GWAS.chr&quot;, x,&quot;B&quot;)) }) DSI::datashield.assign.resource(conns[2], &quot;phenotypes_resource&quot;, &quot;GWAS.ega_phenotypes_2&quot;) # Cohort 3 resources lapply(1:21, function(x){ DSI::datashield.assign.resource(conns[3], paste0(&quot;chr&quot;, x), paste0(&quot;GWAS.chr&quot;, x,&quot;C&quot;)) }) DSI::datashield.assign.resource(conns[3], &quot;phenotypes_resource&quot;, &quot;GWAS.ega_phenotypes_3&quot;) DSI::datashield.assign.expr(conns = conns, symbol = &quot;phenotypes&quot;, expr = as.symbol(&quot;as.resource.data.frame(phenotypes_resource)&quot;)) There is one crucial difference between this analysis and the GWAS, here we dont need to resolve the resources. This is for memory efficiency purposes. When we calculate a PRS, we are only interested in a small selection of SNPs, for that reason the (potentially) huge VCF files will be trimmed before being resolved, so only the relevant SNPs are loaded in the memory. For that reason the resolving of the resources is delegated to the ds.PRS function, which will perform this trimming according to the SNPs of interest yielded by the PGS catalog query or the prs_table table. 4.6 Calculate the PRS The PRS results will be added to the phenotypes table to be later studied using a pooled GLM. To do that, the following arguments of the function ds.PRS will be used: table: Name of the table where the results will be merged. table_id_column: Number of the column in the table table that contains the individuals ID to merge the results from the PRS. table_prs_name: Name to append to the PRS results. It will take the structure prs_table_prs_name and prs_nw_table_prs_name. 4.6.1 PGS Catalog Example For this example we will calculate the PRS associated to the trait HDL Cholesterol and Thyroid cancer, which corresponds to the PGS ID PGS000660 and PGS000636 resources &lt;- paste0(&quot;chr&quot;, 1:21) names(resources) &lt;- paste0(&quot;chr&quot;, 1:21) resources &lt;- as.list(resources) # HDL cholesterol ds.PRS(resources = resources, pgs_id = &quot;PGS000660&quot;, table = &quot;phenotypes&quot;, table_id_column = &quot;subject_id&quot;) # Thyroid cancer ds.PRS(resources = resources, pgs_id = &quot;PGS000636&quot;, table = &quot;phenotypes&quot;, table_id_column = &quot;subject_id&quot;) We can check that the results have been correctly added to the phenotypes table. tail(ds.colnames(&#39;phenotypes&#39;)[[1]]) [1] &quot;prs_PGS000660&quot; &quot;prs_nw_PGS000660&quot; &quot;n_snps_PGS000660&quot; &quot;prs_PGS000636&quot; [5] &quot;prs_nw_PGS000636&quot; &quot;n_snps_PGS000636&quot; 4.6.2 Custom prs_table example Here we will illustrate a use case with a custom prs_table, please note that the proposed SNPs of interest and betas are totally arbitrary. We will first assemble the prs_table table following the indications found on the Details section of ?ds.PRS (Schema 1). prs_table &lt;- data.frame(chr_name = c(9, 9, 9, 9, 1, 1, 2, 2), chr_position = c(177034, 161674, 140859, 119681, 60351, 825410, 154629, 145710), effect_allele = c(&quot;T&quot;, &quot;C&quot;, &quot;G&quot;, &quot;C&quot;, &quot;G&quot;, &quot;G&quot;, &quot;T&quot;, &quot;A&quot;), reference_allele = c(&quot;G&quot;, &quot;T&quot;, &quot;A&quot;, &quot;T&quot;, &quot;A&quot;, &quot;A&quot;, &quot;G&quot;, &quot;G&quot;), effect_weight = c(0.5, 0.2, 0.1, 0.2, 0.1, 0.3, 0.1, 0.8)) Now we can pass the custom prs_table to the PRS function to retrieve the aggregated results. resources &lt;- paste0(&quot;chr&quot;, 1:21) names(resources) &lt;- paste0(&quot;chr&quot;, 1:21) resources &lt;- as.list(resources) ds.PRS(resources = resources, prs_table = prs_table, table = &quot;phenotypes&quot;, table_id_column = &quot;subject_id&quot;, table_prs_name = &quot;custom_prs_table_results&quot;) 4.7 Study of the PRS results We can fit pooled GLM models using the function ds.glm. In this use case we will fit a model to relate the HDL.cholesterol to prs_PGS000660 adjusted by sex. The same will be done with the prs_PGS000636. ds.glm(formula = &quot;hdl_cholesterol ~ prs_PGS000660 + sex&quot;, family = &quot;gaussian&quot;, data = &quot;phenotypes&quot;)$coefficients Estimate Std. Error z-value p-value low0.95CI (Intercept) 1.576448314 0.178438076 8.8347081 1.003600e-18 1.22671611 prs_PGS000660 -0.003678982 0.009899804 -0.3716217 7.101746e-01 -0.02308224 sexmale 0.002311580 0.016140511 0.1432161 8.861195e-01 -0.02932324 high0.95CI (Intercept) 1.92618052 prs_PGS000660 0.01572428 sexmale 0.03394640 ds.glm(formula = &quot;hdl_cholesterol ~ prs_PGS000636 + sex&quot;, family = &quot;gaussian&quot;, data = &quot;phenotypes&quot;)$coefficients Estimate Std. Error z-value p-value low0.95CI (Intercept) 1.522002437 0.01614425 94.2751901 0.0000000 1.49036028 prs_PGS000636 -0.066872228 0.06553929 -1.0203380 0.3075682 -0.19532688 sexmale 0.002416221 0.01613787 0.1497237 0.8809826 -0.02921342 high0.95CI (Intercept) 1.55364459 prs_PGS000636 0.06158242 sexmale 0.03404586 datashield.logout(conns) References "],["differential-gene-expression-dge-analysis.html", "5 Differential gene expression (DGE) analysis 5.1 Connection to the Opal server 5.2 Assign the RSE resource 5.3 Inspect the RSE 5.4 Pre-processing for RNAseq data 5.5 DGE analysis 5.6 Surrogate variable analysis", " 5 Differential gene expression (DGE) analysis  RESOURCES USED ALONG THIS SECTION From https://opal-demo.obiba.org/ : STUDY TABLE PROFILE cohort1 OMICS.tcga_liver omics In this section we will illustrate how to perform transcriptomic data analysis using data from TCGA project. We have uploaded to the demo Opal server a resource called tcga_liver whose URL is http://duffel.rail.bio/recount/TCGA/rse_gene_liver.Rdata which is available through the recount project. The RangedSummarizedExperiment (RSE) objects are part of the BioConductor project, as a brief summary, this types of objects are designed to contain different multi omic data, they can also contain the individuals phenotypes and additional metadata associated with a particular experiment. For further information about what are RangedSummarizedExperiment please take a look at the official documentation The resource used on this section contains a RangedSummarizedExperimentwith the RNAseq profiling of liver cancer data from TCGA. The resource is located inside the OMICS project. Some summaries of the dataset are the following: TCGA Liver data Number of individuals 424 Number of genes 58,037 Number of covariate fields 864 The structure used is illustrated on the following figure. Figure 5.1: Proposed infrastructure to perform DGE studies. The data analyst corresponds to the RStudio session, which through DataSHIELD Interface (DSI) connects with the Opal server. This Opal server contains a resource that corresponds to the TCGA liver RSE. We illustrate a differential expression analysis to compare RNAseq profiling of women vs men (variable gdc_cases.demographic.gender). The DGE analysis is normally performed using limma package. In that case, as we are analyzing RNA-seq data, limma + voom method will be required. The following use cases will be illustrated: DGE analysis DGE analysis adjusting for surrogate variables 5.1 Connection to the Opal server We have to create an Opal connection object to the cohort server. We do that using the following functions. require(&#39;DSI&#39;) require(&#39;DSOpal&#39;) require(&#39;dsBaseClient&#39;) require(&#39;dsOmicsClient&#39;) builder &lt;- DSI::newDSLoginBuilder() builder$append(server = &quot;cohort1&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) logindata &lt;- builder$build() conns &lt;- DSI::datashield.login(logins = logindata) 5.2 Assign the RSE resource Now that we have created a connection object to the Opal, we have started a new R session on the server, our analysis will take place in this remote session, so we have to load the data into it. In this use case we will use one resource from the OMICS project hosted on the demo Opal server. This resources correspond to RangedsummarizedExperiment dataset. The names of the resource is tcga_liver, we will refer to it using the string OMICS.tcga_liver. DSI::datashield.assign.resource(conns, &quot;rse_resource&quot;, &quot;OMICS.tcga_liver&quot;) Now we have assigned the resource named OMICS.tcga_liver into our remote R session. We have assigned it to a variable called rse_resource. To verify this step has been performed correctly, we could use the ds.class function to check for their class and that they exist on the remote sessions. ds.class(&quot;rse_resource&quot;) $cohort1 [1] &quot;RDataFileResourceClient&quot; &quot;FileResourceClient&quot; [3] &quot;ResourceClient&quot; &quot;R6&quot; We can see that the object rse_resource exists in the server. Finally the resource is resolved to retrieve the data in the remote session. DSI::datashield.assign.expr(conns = conns, symbol = &quot;rse&quot;, expr = as.symbol(&quot;as.resource.object(rse_resource)&quot;)) Now we have resolved the resource named rse_resource into our remote R session. The object retrieved has been assigned into the variable named rse. We can check the process was successful as we did before. ds.class(&quot;rse&quot;) $cohort1 [1] &quot;RangedSummarizedExperiment&quot; attr(,&quot;package&quot;) [1] &quot;SummarizedExperiment&quot; 5.3 Inspect the RSE The number of features and samples can be inspected with: ds.dim(&quot;rse&quot;) $`dimensions of rse in cohort1` [1] 58037 424 $`dimensions of rse in combined studies` [1] 58037 424 And the names of the features using the same function used in the case of analyzing an ExpressionSet: name.features &lt;- ds.featureNames(&quot;rse&quot;) lapply(name.features, head) $cohort1 [1] &quot;ENSG00000000003.14&quot; &quot;ENSG00000000005.5&quot; &quot;ENSG00000000419.12&quot; [4] &quot;ENSG00000000457.13&quot; &quot;ENSG00000000460.16&quot; &quot;ENSG00000000938.12&quot; Also the covariate names can be inspected by: name.vars &lt;- ds.featureData(&quot;rse&quot;) lapply(name.vars, head, n=15) $cohort1 [1] &quot;project&quot; [2] &quot;sample&quot; [3] &quot;experiment&quot; [4] &quot;run&quot; [5] &quot;read_count_as_reported_by_sra&quot; [6] &quot;reads_downloaded&quot; [7] &quot;proportion_of_reads_reported_by_sra_downloaded&quot; [8] &quot;paired_end&quot; [9] &quot;sra_misreported_paired_end&quot; [10] &quot;mapped_read_count&quot; [11] &quot;auc&quot; [12] &quot;sharq_beta_tissue&quot; [13] &quot;sharq_beta_cell_type&quot; [14] &quot;biosample_submission_date&quot; [15] &quot;biosample_publication_date&quot; We can visualize the levels of the variable having gender information that will be our condition (i.e., we are interested in obtaining genes that are differentially expressed between males and females). ds.table1D(&quot;rse$gdc_cases.demographic.gender&quot;) $counts rse$gdc_cases.demographic.gender female 143 male 281 Total 424 $percentages rse$gdc_cases.demographic.gender female 33.73 male 66.27 Total 100.00 $validity [1] &quot;All tables are valid!&quot; 5.4 Pre-processing for RNAseq data We have implemented a function called ds.RNAseqPreproc() to perform RNAseq data pre-processing that includes: Transforming data into log2 CPM units Filtering lowly-expressed genes Data normalization ds.RNAseqPreproc(&#39;rse&#39;, group = &#39;gdc_cases.demographic.gender&#39;, newobj.name = &#39;rse.pre&#39;) Note that it is recommended to indicate the grouping variable (i.e., condition). Once data has been pre-processed, we can perform differential expression analysis. Notice how dimensions have changed given the fact that we have removed genes with low expression which are expected to do not be differentially expressed. ds.dim(&#39;rse&#39;) $`dimensions of rse in cohort1` [1] 58037 424 $`dimensions of rse in combined studies` [1] 58037 424 ds.dim(&#39;rse.pre&#39;) $`dimensions of rse.pre in cohort1` [1] 40363 424 $`dimensions of rse.pre in combined studies` [1] 40363 424 5.5 DGE analysis The differential expression analysis in dsOmicsClient/dsOmics is implemented in the funcion ds.limma(). This functions runs a limma-pipeline for microarray data and for RNAseq data allows: oom + limma DESeq2 edgeR We recommend to use the voom + limma pipeline proposed here given its versatility and that limma is much faster than DESeq2 and edgeR. By default, the function considers that data is obtained from a microarray experiment (type.data = \"microarray\"). Therefore, as we are analyzing RNAseq data, we must indicate that type.data = \"RNAse\". ans.gender &lt;- ds.limma(model = ~ gdc_cases.demographic.gender, Set = &quot;rse.pre&quot;, type.data = &quot;RNAseq&quot;) The top differentially expressed genes can be visualized by: ans.gender $cohort1 # A tibble: 40,363 x 7 id n beta SE t P.Value adj.P.Val &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 ENSG00000274655.1 424 -12.4 0.0761 -52.1 2.74e-187 1.11e-182 2 ENSG00000270641.1 424 -10.2 0.461 -43.8 5.21e-160 1.05e-155 3 ENSG00000229807.10 424 -11.0 0.0603 -39.5 1.08e-144 1.45e-140 4 ENSG00000277577.1 424 -11.3 0.0651 -36.0 2.27e-131 2.29e-127 5 ENSG00000233070.1 424 10.9 0.0885 35.5 1.85e-129 1.49e-125 6 ENSG00000260197.1 424 10.2 0.118 32.9 3.72e-119 2.50e-115 7 ENSG00000213318.4 424 11.4 0.128 31.9 5.57e-115 3.21e-111 8 ENSG00000278039.1 424 -7.78 0.0812 -28.8 3.85e-102 1.94e- 98 9 ENSG00000067048.16 424 9.62 0.0894 27.4 4.72e- 96 2.12e- 92 10 ENSG00000131002.11 424 11.4 0.0924 27.3 9.63e- 96 3.89e- 92 # ... with 40,353 more rows attr(,&quot;class&quot;) [1] &quot;dsLimma&quot; &quot;list&quot; We can verify whether the distribution of the observed p-values are the ones we expect in this type of analyses: hist(ans.gender$cohort1$P.Value, xlab=&quot;Raw p-value gender effect&quot;, main=&quot;&quot;, las=1, cex.lab=1.5, cex.axis=1.2, col=&quot;gray&quot;) 5.6 Surrogate variable analysis We can also check whether there is inflation just executing qqplot(ans.gender$cohort1$P.Value) So, in that case, the model needs to remove unwanted variability (\\(\\lambda &gt; 2\\)). If so, we can use surrogate variable analysis just changing the argument sva=TRUE. ans.gender.sva &lt;- ds.limma(model = ~ gdc_cases.demographic.gender, Set = &quot;rse.pre&quot;, type.data = &quot;RNAseq&quot;, sva = TRUE) Now the inflation has dramatically been reduced (\\(\\lambda &gt; 1.12\\)). qqplot(ans.gender.sva$cohort1$P.Value) We can add annotation to the output that is available in our RSE object. We can have access to this information by: ds.fvarLabels(&#39;rse.pre&#39;) $cohort1 [1] &quot;chromosome&quot; &quot;start&quot; &quot;end&quot; &quot;width&quot; &quot;strand&quot; [6] &quot;gene_id&quot; &quot;bp_length&quot; &quot;symbol&quot; attr(,&quot;class&quot;) [1] &quot;dsfvarLabels&quot; &quot;list&quot; So, we can run: ans.gender.sva &lt;- ds.limma(model = ~ gdc_cases.demographic.gender, Set = &quot;rse.pre&quot;, type.data = &quot;RNAseq&quot;, sva = TRUE, annotCols = c(&quot;chromosome&quot;)) The results are: ans.gender.sva $cohort1 # A tibble: 40,363 x 8 id n beta SE t P.Value adj.P.Val chromosome &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 ENSG00000274655.1 424 -12.4 0.0761 -52.1 2.74e-187 1.11e-182 chrX 2 ENSG00000270641.1 424 -10.2 0.461 -43.8 5.21e-160 1.05e-155 chrX 3 ENSG00000229807.10 424 -11.0 0.0603 -39.5 1.08e-144 1.45e-140 chrX 4 ENSG00000277577.1 424 -11.3 0.0651 -36.0 2.27e-131 2.29e-127 chrX 5 ENSG00000233070.1 424 10.9 0.0885 35.5 1.85e-129 1.49e-125 chrY 6 ENSG00000260197.1 424 10.2 0.118 32.9 3.72e-119 2.50e-115 chrY 7 ENSG00000213318.4 424 11.4 0.128 31.9 5.57e-115 3.21e-111 chr16 8 ENSG00000278039.1 424 -7.78 0.0812 -28.8 3.85e-102 1.94e- 98 chrX 9 ENSG00000067048.16 424 9.62 0.0894 27.4 4.72e- 96 2.12e- 92 chrY 10 ENSG00000131002.11 424 11.4 0.0924 27.3 9.63e- 96 3.89e- 92 chrY # ... with 40,353 more rows attr(,&quot;class&quot;) [1] &quot;dsLimma&quot; &quot;list&quot; The function has another arguments that can be used to fit other type of models: sva: estimate surrogate variables annotCols: to add annotation available in the method: Linear regression (ls) or robust regression (robust) used in limma (lmFit) robust: robust method used for outlier sample variances used in limma (eBayes) normalization: normalization method used in the voom transformation (default none) voomQualityWeights: should voomQualityWeights function be used instead of voom? (default FALSE) big: should SmartSVA be used instead of SVA (useful for big sample size or when analyzing epigenome data. Default FALSE) We have also implemented two other functions ds.DESeq2 and ds.edgeR that perform DGE analysis using DESeq2 and edgeR methods. This is the R code used to that purpose: To be supplied We close the DataSHIELD session by: datashield.logout(conns) "],["epigenome-wide-association-analysis-ewas.html", "6 Epigenome-wide association analysis (EWAS) 6.1 Initial steps for all use cases 6.2 Single CpG pooled analysis 6.3 Multiple CpGs pooled analysis 6.4 Full genome meta-analysis 6.5 Adjusting for surrogate variables", " 6 Epigenome-wide association analysis (EWAS)  RESOURCES USED ALONG THIS SECTION From https://opal-demo.obiba.org/ : STUDY TABLE PROFILE cohort1 OMICS.GSE66351_1 omics cohort2 OMICS.GSE66351_2 omics In this section we will illustrate how to perform an epigenome-wide association analysis (EWAS) using methylation data. EWAS requires basically the same statistical methods as those used in DGE. It should be noticed that the pooled analysis we are going to illustrate here can also be performed with transcriptomic data, however the data needs to be harmonized beforehand to ensure each study has the same range values. For EWAS where methylation is measured using beta values (e.g CpG data are in the range 0-1) this is not a problem. In any case, adopting the meta-analysis approach could be a safe option without the need of harmonization. Moreover, we encourage to perform pooled analysis only on the significant hits obtained by the meta-analysis, since it is a much slower methodology. The data used in this section has been downloaded from GEO (accession number GSE66351) which contains DNA methylation profiling (Illumina 450K array). Data corresponds to CpGs beta values measured in the superior temporal gyrus and prefrontal cortex brain regions of patients with Alzheimers. This kind of data is encapsulated on a type of R object called ExpressionSet, this objects are part of the BioConductor project and are meant to contain different sources of genomic data, alongside the genomic data they can also contain the phenotypes and metadata associated to a study. Researchers who are not familiar with ExpressionSet can find further information here. The data that we will be using along this section is an ExpressionSet objects. Notice that genomic data is encoded as beta-values that ensure data harmonization across studies. In order to illustrate how to perform data analyses using federated data, we have split the data into two synthetic cohorts (split by individuals). We have created two resources on the demo Opal server called GSE66351_1 and GSE66351_2 respectively. They can be found inside the OMICS project. Some summaries of the datasets are the following: Cohort 1 Cohort 2 Total Number of CpGs 481,868 481,868 481,868 Number of individuals 100 90 190 Number of covariates 49 49 49 Number of annotation features 37 37 37 The structure used is illustrated on the following figure. Figure 6.1: Proposed infrastructure to perform EWAS studies. The data analyst corresponds to the RStudio session, which through DataSHIELD Interface (DSI) connects with the Opal server. The Opal servers contain a resource that correspond to the GEO:GSE66351 ExpressionSet (subseted by individuals). We will illustrate the following use cases: Single CpG pooled analysis Multiple CpGs pooled analysis Full genome meta-analysis Full genome meta-analysis adjusting for surrogate variables 6.1 Initial steps for all use cases 6.1.1 Connection to the Opal server We have to create an Opal connection object to the different cohorts server. We do that using the following functions. require(&#39;DSI&#39;) require(&#39;DSOpal&#39;) require(&#39;dsBaseClient&#39;) require(&#39;dsOmicsClient&#39;) builder &lt;- DSI::newDSLoginBuilder() builder$append(server = &quot;cohort1&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) builder$append(server = &quot;cohort2&quot;, url = &quot;https://opal-demo.obiba.org/&quot;, user = &quot;dsuser&quot;, password = &quot;P@ssw0rd&quot;, driver = &quot;OpalDriver&quot;, profile = &quot;omics&quot;) logindata &lt;- builder$build() conns &lt;- DSI::datashield.login(logins = logindata) It is important to note that in this use case, we are only using one server (https://opal-demo.obiba.org/), on this server there are all the resources that correspond to the different cohorts. On a more real scenario each one of the builder$append instructions would be connecting to a different server. 6.1.2 Assign the ExpressionSet resource Now that we have created a connection object to the different Opals, we have started two R sessions, our analysis will take place on those remote sessions, so we have to load the data into them. In this use case we will use 2 different resources from the OMICS project hosted on the demo Opal server. The names of the resources are GSE66351_X (where X is the cohort identifier 1/2). Following the Opal syntax, we will refer to them using the string OMICS.GSE66351_X. We have to refer specifically to each different server by using conns[X], this allows us to communicate with the server of interest to indicate to it the resource that it has to load. # Cohort 1 resource load DSI::datashield.assign.resource(conns[1], &quot;eSet_resource&quot;, &quot;OMICS.GSE66351_1&quot;) # Cohort 2 resource load DSI::datashield.assign.resource(conns[2], &quot;eSet_resource&quot;, &quot;OMICS.GSE66351_2&quot;) Now we have assigned all the resources named into our remote R sessions. We have assigned them to the variables called eSet_resource. To verify this step has been performed correctly, we can use the ds.class function to check for their class and that they exist on the remote sessions. ds.class(&quot;eSet_resource&quot;) $cohort1 [1] &quot;RDataFileResourceClient&quot; &quot;FileResourceClient&quot; [3] &quot;ResourceClient&quot; &quot;R6&quot; $cohort2 [1] &quot;RDataFileResourceClient&quot; &quot;FileResourceClient&quot; [3] &quot;ResourceClient&quot; &quot;R6&quot; We can see that the object eSet_resource exists in both servers. Finally the resource is resolved to retrieve the data in the remote sessions. DSI::datashield.assign.expr(conns = conns, symbol = &quot;eSet&quot;, expr = as.symbol(&quot;as.resource.object(eSet_resource)&quot;)) Now we have resolved the resource named eSet_resource into our remote R session. The object retrieved has been assigned into the variable named eSet. We can check the process was successful as we did before. ds.class(&quot;eSet&quot;) $cohort1 [1] &quot;ExpressionSet&quot; attr(,&quot;package&quot;) [1] &quot;Biobase&quot; $cohort2 [1] &quot;ExpressionSet&quot; attr(,&quot;package&quot;) [1] &quot;Biobase&quot; 6.1.3 Inspect the ExpressionSet Feature names can be returned by: fn &lt;- ds.featureNames(&quot;eSet&quot;) lapply(fn, head) $cohort1 [1] &quot;cg00000029&quot; &quot;cg00000108&quot; &quot;cg00000109&quot; &quot;cg00000165&quot; &quot;cg00000236&quot; [6] &quot;cg00000289&quot; $cohort2 [1] &quot;cg00000029&quot; &quot;cg00000108&quot; &quot;cg00000109&quot; &quot;cg00000165&quot; &quot;cg00000236&quot; [6] &quot;cg00000289&quot; Experimental phenotypes variables can be obtained by: fn &lt;- ds.varLabels(&quot;eSet&quot;) lapply(fn, head) $cohort1 [1] &quot;title&quot; &quot;geo_accession&quot; &quot;status&quot; &quot;submission_date&quot; [5] &quot;last_update_date&quot; &quot;type&quot; $cohort2 [1] &quot;title&quot; &quot;geo_accession&quot; &quot;status&quot; &quot;submission_date&quot; [5] &quot;last_update_date&quot; &quot;type&quot; The columns of the annotation can be obtained by: fn &lt;- ds.fvarLabels(&quot;eSet&quot;) lapply(fn, head) $cohort1 [1] &quot;ID&quot; &quot;Name&quot; &quot;AddressA_ID&quot; &quot;AlleleA_ProbeSeq&quot; [5] &quot;AddressB_ID&quot; &quot;AlleleB_ProbeSeq&quot; $cohort2 [1] &quot;ID&quot; &quot;Name&quot; &quot;AddressA_ID&quot; &quot;AlleleA_ProbeSeq&quot; [5] &quot;AddressB_ID&quot; &quot;AlleleB_ProbeSeq&quot; 6.2 Single CpG pooled analysis Once the methylation data have been loaded into the opal server, we can perform different type of analyses using functions from the dsOmicsClient package. Let us start by illustrating how to analyze a single CpG from two cohorts by using an approach that is mathematically equivalent to placing all individual-level (pooled). ans &lt;- ds.lmFeature(feature = &quot;cg07363416&quot;, model = ~ diagnosis + Sex, Set = &quot;eSet&quot;, datasources = conns) ans Estimate Std. Error p-value cg07363416 0.03459886 0.02504291 0.1670998 attr(,&quot;class&quot;) [1] &quot;dsLmFeature&quot; &quot;matrix&quot; &quot;array&quot; 6.3 Multiple CpGs pooled analysis The same analysis can be performed for multiple features. This process can be parallelized using mclapply function from the multicore package (only works on GNU/Linux, not on Windows). ans &lt;- ds.lmFeature(feature = c(&quot;cg00000029&quot;, &quot;cg00000108&quot;, &quot;cg00000109&quot;, &quot;cg00000165&quot;), model = ~ diagnosis + Sex, Set = &quot;eSet&quot;, datasources = conns, mc.cores = 20) If the feature argument is not supplied, all the features will be analyzed, please note that this process can be extremely slow if there is a huge number of features; for example, on the case we are illustrating we have over 400K features, so this process would take too much time. If all the features are to be studied, we recommend switching to meta-analysis methods. More information on the next section. 6.4 Full genome meta-analysis We can adopt another strategy that is to run a glm of each feature independently at each study using limma package (which is really fast) and then combine the results (i.e. meta-analysis approach). ans.limma &lt;- ds.limma(model = ~ diagnosis + Sex, Set = &quot;eSet&quot;, datasources = conns) Then, we can visualize the top genes at each study (i.e server) by: lapply(ans.limma, head) $cohort1 # A tibble: 6 x 7 id n beta SE t P.Value adj.P.Val &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 cg13138089 100 -0.147 0.0122 -6.62 0.00000000190 0.000466 2 cg23859635 100 -0.0569 0.00520 -6.58 0.00000000232 0.000466 3 cg13772815 100 -0.0820 0.0135 -6.50 0.00000000327 0.000466 4 cg12706938 100 -0.0519 0.00872 -6.45 0.00000000425 0.000466 5 cg24724506 100 -0.0452 0.00775 -6.39 0.00000000547 0.000466 6 cg02812891 100 -0.125 0.0163 -6.33 0.00000000731 0.000466 $cohort2 # A tibble: 6 x 7 id n beta SE t P.Value adj.P.Val &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 cg04046629 90 -0.101 0.0128 -5.91 0.0000000621 0.0172 2 cg07664323 90 -0.0431 0.00390 -5.85 0.0000000822 0.0172 3 cg27098804 90 -0.0688 0.0147 -5.79 0.000000107 0.0172 4 cg08933615 90 -0.0461 0.00791 -5.55 0.000000298 0.0360 5 cg18349298 90 -0.0491 0.00848 -5.42 0.000000507 0.0489 6 cg02182795 90 -0.0199 0.0155 -5.36 0.000000670 0.0538 The annotation can be added by using the argument annotCols. It should be a vector with the columns of the annotation available in the ExpressionSet or RangedSummarizedExperiment that want to be showed. To obtain the available annotation columns revisit #ewas-inspect. ans.limma.annot &lt;- ds.limma(model = ~ diagnosis + Sex, Set = &quot;eSet&quot;, annotCols = c(&quot;CHR&quot;, &quot;UCSC_RefGene_Name&quot;), datasources = conns) lapply(ans.limma.annot, head) $cohort1 # A tibble: 6 x 9 id n beta SE t P.Value adj.P.Val CHR UCSC_RefGene_Na~ &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 cg1313~ 100 -0.147 0.0122 -6.62 1.90e-9 0.000466 2 &quot;ECEL1P2&quot; 2 cg2385~ 100 -0.0569 0.00520 -6.58 2.32e-9 0.000466 2 &quot;MTA3&quot; 3 cg1377~ 100 -0.0820 0.0135 -6.50 3.27e-9 0.000466 17 &quot;&quot; 4 cg1270~ 100 -0.0519 0.00872 -6.45 4.25e-9 0.000466 19 &quot;MEX3D&quot; 5 cg2472~ 100 -0.0452 0.00775 -6.39 5.47e-9 0.000466 19 &quot;ISOC2;ISOC2;IS~ 6 cg0281~ 100 -0.125 0.0163 -6.33 7.31e-9 0.000466 2 &quot;ECEL1P2&quot; $cohort2 # A tibble: 6 x 9 id n beta SE t P.Value adj.P.Val CHR UCSC_RefGene_Na~ &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 cg0404~ 90 -0.101 0.0128 -5.91 6.21e-8 0.0172 11 &quot;CD6&quot; 2 cg0766~ 90 -0.0431 0.00390 -5.85 8.22e-8 0.0172 6 &quot;MUC21&quot; 3 cg2709~ 90 -0.0688 0.0147 -5.79 1.07e-7 0.0172 11 &quot;CD6&quot; 4 cg0893~ 90 -0.0461 0.00791 -5.55 2.98e-7 0.0360 1 &quot;&quot; 5 cg1834~ 90 -0.0491 0.00848 -5.42 5.07e-7 0.0489 3 &quot;RARRES1;RARRES~ 6 cg0218~ 90 -0.0199 0.0155 -5.36 6.70e-7 0.0538 8 &quot;&quot; Then, the last step is to meta-analyze the results. Different methods can be used to this end. We have implemented a method that meta-analyze the p-pvalues of each study as follows: ans.meta &lt;- metaPvalues(ans.limma) ans.meta # A tibble: 481,868 x 4 id cohort1 cohort2 p.meta &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 cg13138089 0.00000000190 0.00000763 4.78e-13 2 cg25317941 0.0000000179 0.00000196 1.12e-12 3 cg02812891 0.00000000731 0.00000707 1.63e-12 4 cg12706938 0.00000000425 0.0000161 2.14e-12 5 cg16026647 0.000000101 0.000000797 2.51e-12 6 cg12695465 0.00000000985 0.0000144 4.33e-12 7 cg21171625 0.000000146 0.00000225 9.78e-12 8 cg13772815 0.00000000327 0.000122 1.18e-11 9 cg00228891 0.000000166 0.00000283 1.38e-11 10 cg21488617 0.0000000186 0.0000299 1.62e-11 # ... with 481,858 more rows We can verify that the results are pretty similar to those obtained using pooled analyses. Here we compute the association for the top two CpGs: res &lt;- ds.lmFeature(feature = ans.meta$id[1:2], model = ~ diagnosis + Sex, Set = &quot;eSet&quot;, datasources = conns) res Estimate Std. Error p-value p.adj cg25317941 -0.03452376 0.004303781 1.042679e-15 1.057482e-15 cg13138089 -0.13733479 0.017124046 1.057482e-15 1.057482e-15 attr(,&quot;class&quot;) [1] &quot;dsLmFeature&quot; &quot;matrix&quot; &quot;array&quot; We can create a QQ-plot by using the function qqplot available in our package. qqplot(ans.meta$p.meta) Here In some cases inflation can be observed, so that, correction for cell-type or surrogate variables must be performed. We describe how we can do that in the next two sections. 6.5 Adjusting for surrogate variables The vast majority of omic studies require to control for unwanted variability. The surrogate variable analysis (SVA) can address this issue by estimating some hidden covariates that capture differences across individuals due to some artifacts such as batch effects or sample quality among others. The method is implemented in SVA package. Performing this type of analysis using the ds.lmFeature function is not allowed since estimating SVA would require to implement a non-disclosive method that computes SVA from the different servers. This will be a future topic of the dsOmicsClient. For that reason we have to adopt a compromise solution which is to perform the SVA independently at each study. We use the ds.limma function to perform the analyses adjusted for SVA at each study. ans.sva &lt;- ds.limma(model = ~ diagnosis + Sex, Set = &quot;eSet&quot;, sva = TRUE, annotCols = c(&quot;CHR&quot;, &quot;UCSC_RefGene_Name&quot;)) ans.sva $cohort1 # A tibble: 481,868 x 9 id n beta SE t P.Value adj.P.Val CHR UCSC_RefGene_Na~ &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 cg1313~ 100 -0.147 0.0122 -6.62 1.90e-9 0.000466 2 &quot;ECEL1P2&quot; 2 cg2385~ 100 -0.0569 0.00520 -6.58 2.32e-9 0.000466 2 &quot;MTA3&quot; 3 cg1377~ 100 -0.0820 0.0135 -6.50 3.27e-9 0.000466 17 &quot;&quot; 4 cg1270~ 100 -0.0519 0.00872 -6.45 4.25e-9 0.000466 19 &quot;MEX3D&quot; 5 cg2472~ 100 -0.0452 0.00775 -6.39 5.47e-9 0.000466 19 &quot;ISOC2;ISOC2;IS~ 6 cg0281~ 100 -0.125 0.0163 -6.33 7.31e-9 0.000466 2 &quot;ECEL1P2&quot; 7 cg2766~ 100 -0.0588 0.0198 -6.33 7.48e-9 0.000466 16 &quot;ANKRD11&quot; 8 cg1537~ 100 -0.0709 0.0115 -6.32 7.83e-9 0.000466 2 &quot;LPIN1&quot; 9 cg1552~ 100 -0.0446 0.00750 -6.29 8.69e-9 0.000466 10 &quot;&quot; 10 cg1269~ 100 -0.0497 0.00155 -6.27 9.85e-9 0.000475 6 &quot;GCNT2;GCNT2;GC~ # ... with 481,858 more rows $cohort2 # A tibble: 481,868 x 9 id n beta SE t P.Value adj.P.Val CHR UCSC_RefGene_Name &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 1 cg040~ 90 -0.101 0.0128 -5.91 6.21e-8 0.0172 11 &quot;CD6&quot; 2 cg076~ 90 -0.0431 0.00390 -5.85 8.22e-8 0.0172 6 &quot;MUC21&quot; 3 cg270~ 90 -0.0688 0.0147 -5.79 1.07e-7 0.0172 11 &quot;CD6&quot; 4 cg089~ 90 -0.0461 0.00791 -5.55 2.98e-7 0.0360 1 &quot;&quot; 5 cg183~ 90 -0.0491 0.00848 -5.42 5.07e-7 0.0489 3 &quot;RARRES1;RARRES1&quot; 6 cg021~ 90 -0.0199 0.0155 -5.36 6.70e-7 0.0538 8 &quot;&quot; 7 cg160~ 90 -0.0531 0.0196 -5.31 7.97e-7 0.0548 17 &quot;MEIS3P1&quot; 8 cg012~ 90 -0.0537 0.00971 -5.18 1.39e-6 0.0582 7 &quot;HOXA2&quot; 9 cg251~ 90 -0.0224 0.00736 -5.15 1.57e-6 0.0582 3 &quot;ZBTB20;ZBTB20;ZB~ 10 cg074~ 90 -0.0475 0.00166 -5.13 1.67e-6 0.0582 22 &quot;C22orf27&quot; # ... with 481,858 more rows attr(,&quot;class&quot;) [1] &quot;dsLimma&quot; &quot;list&quot; Then, data can be combined meta-anlyzed as follows: ans.meta.sv &lt;- metaPvalues(ans.sva) ans.meta.sv # A tibble: 481,868 x 4 id cohort1 cohort2 p.meta &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 cg13138089 0.00000000190 0.00000763 4.78e-13 2 cg25317941 0.0000000179 0.00000196 1.12e-12 3 cg02812891 0.00000000731 0.00000707 1.63e-12 4 cg12706938 0.00000000425 0.0000161 2.14e-12 5 cg16026647 0.000000101 0.000000797 2.51e-12 6 cg12695465 0.00000000985 0.0000144 4.33e-12 7 cg21171625 0.000000146 0.00000225 9.78e-12 8 cg13772815 0.00000000327 0.000122 1.18e-11 9 cg00228891 0.000000166 0.00000283 1.38e-11 10 cg21488617 0.0000000186 0.0000299 1.62e-11 # ... with 481,858 more rows And we can revisit the qqplot: qqplot(ans.meta.sv$p.meta) The DataSHIELD session must be closed by: datashield.logout(conns) "],["gwas.html", "7 GWAS", " 7 GWAS TODO "],["internal-structure-of-the-prs-functionality.html", "8 Internal structure of the PRS functionality 8.1 Client 8.2 Server resolver 8.3 Server analysis", " 8 Internal structure of the PRS functionality The PRS function can be divided into three main blocks that perform the required tasks to come up with the results. The three functional blocks are the following: Client: Assemble the prs_table table if PGS Catalog is used, perform calls to the server to subset the resources and calculate the PRS with the subsetted resources. Server resolver: Resolve the selected resources (VCF files) and subset them using the prs_table. Server analysis: Use the resolved resources (small VCF files with only the SNPs of interest according to the prs_table table) to calculate the PRS. In order to introduce a little how those three blocks work internally, schematized flow charts have been designed. To understand the exact inner working of the functionality it is advised to follow the flowcharts alongside the actual source code. Find the links to the three blocks source code, client, server resolver and server analysis. 8.1 Client The client performs two basic tasks. The first one is to select between a user introduced prs_table or to retrieve the prs_table from the PGS Catalog. Please note that prs_table stands for Region Of Interest, which may not be the common term for PGS analysis but it makes sense since it refers to a table that contain the SNPs of interest and their weight to the score. If the user introduces a custom prs_table and a PGS Catalog ID, only the introduced table will be used, discarding the PGS Catalog ID information. Once this table is assembled, the next step is to call the required functions on the study servers. First, the resource resolver is called, and after that, the function that calculates the PRS is called. This is illustrated on the following figure. Figure 8.1: Flow chart of the client block. 8.2 Server resolver The server resolver is in charge of resolving the resources. The interesting aspect is that only a region of interest is actually assigned to the R session, this is to avoid overloading the memory with unnecessary information. There are two different methodologies to perform this subsetting, one is using chromosome names and position and the other is using the SNP ids. Due to the technical specification of VCF files, is much easier to perform the subsetting using chromosome names and positions because there is an indexing file for the VCF files to perform fast queries of regions by position. On the other hand, to filter a VCF file using SNP ids, the whole file has to be scanned, yielding a much slower process. This block is illustrated on the following figure. Figure 8.2: Flow chart of the server resolver block. 8.3 Server analysis Many processes are performed inside the analysis block. For that reason, more than a flow chart, a step by step guide has been illustrated with the objects that are created (or modified) on each step. The most important step on this block is making sure that the alternate (risk) alleles match between the VCF resources and the alternate alleles stated by the prs_table or PGS Catalog. The block is illustrated on the following figure. Figure 8.3: Flow chart of the server analysis block. "],["compression-of-gds-files-vs.-performance.html", "9 Compression of GDS files vs. performance", " 9 Compression of GDS files vs. performance When working with genotype data, OmicSHIELD offers the possibility of using VCF and GDS formats. When a VCF is supplied, internally is converted to a GDS to work with it, for that reason it is always better to start with a GDS to improve the performance of the pipeline. When converting to GDS using gdsfmt, there are many compression options that will affect the final file size. This compression comes with an added cost, which is the read time. For very aggressive compression typically the reading time gets severely affected, so it is good to find a good balance. To help choosing the right compression we provide a comparison table between all the compression options, the table has been extracted from the official documentation of the gdsgmt package. Compression Method Raw ZIP ZIP_ra LZ4 LZ4_ra LZMA LZMA_ra Data Size (MB) 38.1 1.9 2.1 2.8 2.9 1.4 1.4 Compression Percent 100% 5.08% 5.42% 7.39% 7.60% 3.65% 3.78% Reading Time (second) 0.21 202.64 2.97 84.43 0.84 462.1 29.7 At ISGlobal we are using the LZ4_ra compression method because it provides a very good compression level with the least effect to the reading time. "],["session-info.html", "10 Session info", " 10 Session info sessionInfo() R version 4.0.4 (2021-02-15) Platform: x86_64-w64-mingw32/x64 (64-bit) Running under: Windows 10 x64 (build 19042) Matrix products: default locale: [1] LC_COLLATE=Spanish_Spain.1252 LC_CTYPE=Spanish_Spain.1252 [3] LC_MONETARY=Spanish_Spain.1252 LC_NUMERIC=C [5] LC_TIME=Spanish_Spain.1252 attached base packages: [1] stats4 parallel stats graphics grDevices utils datasets [8] methods base other attached packages: [1] org.Hs.eg.db_3.12.0 [2] ggnewscale_0.4.5 [3] enrichplot_1.10.2 [4] DOSE_3.16.0 [5] biomaRt_2.46.3 [6] gt_0.3.1 [7] TxDb.Hsapiens.UCSC.hg19.knownGene_3.2.2 [8] GenomicFeatures_1.42.3 [9] AnnotationDbi_1.52.0 [10] Biobase_2.50.0 [11] GenomicRanges_1.42.0 [12] GenomeInfoDb_1.26.7 [13] IRanges_2.24.1 [14] S4Vectors_0.28.1 [15] BiocGenerics_0.36.0 [16] ggrepel_0.9.1 [17] patchwork_1.1.1 [18] forcats_0.5.1 [19] stringr_1.4.0 [20] dplyr_1.0.5 [21] purrr_0.3.4 [22] readr_1.4.0 [23] tidyr_1.1.3 [24] tibble_3.1.0 [25] ggplot2_3.3.3 [26] tidyverse_1.3.0 [27] magrittr_2.0.1 [28] dsOmicsClient_1.0.7-10 [29] DSLite_1.2.0 [30] dsBaseClient_6.2.0-2 [31] DSOpal_1.3.0 [32] opalr_3.0.0 [33] httr_1.4.2 [34] DSI_1.3.0 [35] R6_2.5.0 [36] progress_1.2.2 [37] BiocStyle_2.18.1 loaded via a namespace (and not attached): [1] utf8_1.2.1 tidyselect_1.1.0 [3] RSQLite_2.2.5 grid_4.0.4 [5] BiocParallel_1.24.1 scatterpie_0.1.6 [7] munsell_0.5.0 codetools_0.2-18 [9] mutoss_0.1-12 withr_2.4.1 [11] colorspace_2.0-0 GOSemSim_2.16.1 [13] highr_0.8 knitr_1.37 [15] rstudioapi_0.13 labeling_0.4.2 [17] MatrixGenerics_1.2.1 Rdpack_2.1.1 [19] GenomeInfoDbData_1.2.4 mnormt_2.0.2 [21] polyclip_1.10-0 bit64_4.0.5 [23] farver_2.1.0 vctrs_0.3.6 [25] generics_0.1.0 TH.data_1.0-10 [27] xfun_0.28 BiocFileCache_1.14.0 [29] graphlayouts_0.7.1 bitops_1.0-6 [31] cachem_1.0.4 fgsea_1.16.0 [33] DelayedArray_0.16.3 assertthat_0.2.1 [35] scales_1.1.1 multcomp_1.4-16 [37] ggraph_2.0.5 gtable_0.3.0 [39] tidygraph_1.2.0 sandwich_3.0-0 [41] rlang_0.4.10 splines_4.0.4 [43] rtracklayer_1.49.5 broom_0.7.6 [45] BiocManager_1.30.12 yaml_2.2.1 [47] reshape2_1.4.4 modelr_0.1.8 [49] backports_1.2.1 qvalue_2.22.0 [51] tools_4.0.4 bookdown_0.24 [53] ellipsis_0.3.1 jquerylib_0.1.4 [55] RColorBrewer_1.1-2 TFisher_0.2.0 [57] Rcpp_1.0.7 plyr_1.8.6 [59] zlibbioc_1.36.0 RCurl_1.98-1.3 [61] prettyunits_1.1.1 openssl_1.4.3 [63] viridis_0.5.1 cowplot_1.1.1 [65] zoo_1.8-9 SummarizedExperiment_1.20.0 [67] haven_2.3.1 fs_1.5.0 [69] data.table_1.13.0 DO.db_2.9 [71] reprex_2.0.0 tmvnsim_1.0-2 [73] mvtnorm_1.1-1 matrixStats_0.58.0 [75] hms_1.0.0 mime_0.10 [77] evaluate_0.14 XML_3.99-0.6 [79] readxl_1.3.1 gridExtra_2.3 [81] compiler_4.0.4 crayon_1.4.1 [83] shadowtext_0.0.8 htmltools_0.5.1.1 [85] lubridate_1.7.10 DBI_1.1.1 [87] tweenr_1.0.2 dbplyr_2.1.1 [89] MASS_7.3-53 rappdirs_0.3.3 [91] Matrix_1.3-2 cli_2.4.0 [93] rbibutils_2.1 metap_1.4 [95] igraph_1.2.6 pkgconfig_2.0.3 [97] sn_2.0.0 rvcheck_0.1.8 [99] GenomicAlignments_1.26.0 numDeriv_2016.8-1.1 [101] xml2_1.3.2 bslib_0.2.4 [103] multtest_2.46.0 XVector_0.30.0 [105] rvest_0.3.6 digest_0.6.27 [107] Biostrings_2.58.0 rmarkdown_2.11 [109] cellranger_1.1.0 fastmatch_1.1-0 [111] curl_4.3 Rsamtools_2.6.0 [113] lifecycle_1.0.0 jsonlite_1.7.2 [115] viridisLite_0.3.0 askpass_1.1 [117] fansi_0.4.2 labelled_2.8.0 [119] pillar_1.5.1 lattice_0.20-41 [121] fastmap_1.1.0 plotrix_3.8-1 [123] survival_3.2-7 GO.db_3.12.1 [125] glue_1.4.2 png_0.1-7 [127] bit_4.0.4 ggforce_0.3.3 [129] stringi_1.5.3 sass_0.3.1 [131] blob_1.2.1 memoise_2.0.0 [133] mathjaxr_1.4-0 "],["contributos.html", "11 Contributos", " 11 Contributos This bookdown has had the contributions by the following people. Juan R Gonzalez, Associate Research Professor at Barcelona Institute for Global Health (ISGlobal) and Adjunct Professor at Department of Mathematics at Autonomous University of Barcelona (UAB). Xavier Escribà-Montagut, PhD researcher at Barcelona Institute for Global Health (ISGlobal) "],["references.html", "12 References", " 12 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
